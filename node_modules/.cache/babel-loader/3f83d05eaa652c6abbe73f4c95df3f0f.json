{"ast":null,"code":"'use strict';\n\nconst DataTypes = require('../../data-types');\n\nconst QueryTypes = require('../../query-types');\n\nconst _require = require('../abstract/query-interface'),\n      QueryInterface = _require.QueryInterface;\n\nconst Utils = require('../../utils');\n/**\n * The interface that Sequelize uses to talk with Postgres database\n */\n\n\nclass PostgresQueryInterface extends QueryInterface {\n  /**\n   * Ensure enum and their values.\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {object} attributes Object representing a list of normalized table attributes\n   * @param {object} [options]\n   * @param {Model}  [model]\n   *\n   * @protected\n   */\n  async ensureEnums(tableName, attributes, options, model) {\n    const keys = Object.keys(attributes);\n    const keyLen = keys.length;\n    let sql = '';\n    let promises = [];\n    let i = 0;\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n          sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n          promises.push(this.sequelize.query(sql, { ...options,\n            plain: true,\n            raw: true,\n            type: QueryTypes.SELECT\n          }));\n        }\n    }\n\n    const results = await Promise.all(promises);\n    promises = [];\n    let enumIdx = 0; // This little function allows us to re-use the same code that prepends or appends new value to enum array\n\n    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {\n      const valueOptions = { ...options\n      };\n      valueOptions.before = null;\n      valueOptions.after = null;\n\n      switch (position) {\n        case 'after':\n          valueOptions.after = relativeValue;\n          break;\n\n        case 'before':\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n\n      promises.splice(spliceStart, 0, () => {\n        return this.sequelize.query(this.queryGenerator.pgEnumAdd(tableName, field, value, valueOptions), valueOptions);\n      });\n    };\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n          // If the enum type doesn't exist then create it\n          if (!results[enumIdx]) {\n            promises.push(() => {\n              return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), { ...options,\n                raw: true\n              });\n            });\n          } else if (!!results[enumIdx] && !!model) {\n            const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);\n            const vals = enumType.values; // Going through already existing values allows us to make queries that depend on those values\n            // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n            // Then we append the rest of new values AFTER the latest already existing value\n            // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n            // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n            // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n\n            let lastOldEnumValue;\n            let rightestPosition = -1;\n\n            for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n              const enumVal = enumVals[oldIndex];\n              const newIdx = vals.indexOf(enumVal);\n              lastOldEnumValue = enumVal;\n\n              if (newIdx === -1) {\n                continue;\n              }\n\n              const newValuesBefore = vals.slice(0, newIdx);\n              const promisesLength = promises.length; // we go in reverse order so we could stop when we meet old value\n\n              for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n                if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                  break;\n                }\n\n                addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n              } // we detect the most 'right' position of old value in new enum array so we can append new values to it\n\n\n              if (newIdx > rightestPosition) {\n                rightestPosition = newIdx;\n              }\n            }\n\n            if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n              const remainingEnumValues = vals.slice(rightestPosition + 1);\n\n              for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n                addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n              }\n            }\n\n            enumIdx++;\n          }\n        }\n    }\n\n    const result = await promises.reduce(async (promise, asyncFunction) => await asyncFunction((await promise)), Promise.resolve()); // If ENUM processed, then refresh OIDs\n\n    if (promises.length) {\n      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n    }\n\n    return result;\n  }\n  /**\n   * @override\n   */\n\n\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = { ...options,\n      type: QueryTypes.FOREIGNKEYS\n    }; // postgres needs some special treatment as those field names returned are all lowercase\n    // in order to keep same result with other dialects.\n\n    const query = this.queryGenerator.getForeignKeyReferencesQuery(tableName, this.sequelize.config.database);\n    const result = await this.sequelize.query(query, queryOptions);\n    return result.map(Utils.camelizeObjectKeys);\n  }\n  /**\n   * Drop specified enum from database (Postgres only)\n   *\n   * @param {string} [enumName]  Enum name to drop\n   * @param {object} options Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  async dropEnum(enumName, options) {\n    options = options || {};\n    return this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)), { ...options,\n      raw: true\n    });\n  }\n  /**\n   * Drop all enums from database (Postgres only)\n   *\n   * @param {object} options Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  async dropAllEnums(options) {\n    options = options || {};\n    const enums = await this.pgListEnums(null, options);\n    return await Promise.all(enums.map(result => this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)), { ...options,\n      raw: true\n    })));\n  }\n  /**\n   * List all enums (Postgres only)\n   *\n   * @param {string} [tableName]  Table whose enum to list\n   * @param {object} [options]    Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  async pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.queryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, { ...options,\n      plain: false,\n      raw: true,\n      type: QueryTypes.SELECT\n    });\n  }\n  /**\n   * Since postgres has a special case for enums, we should drop the related\n   * enum type within the table and attribute\n   *\n   * @override\n   */\n\n\n  async dropTable(tableName, options) {\n    await super.dropTable(tableName, options);\n    const promises = [];\n    const instanceTable = this.sequelize.modelManager.getModel(tableName, {\n      attribute: 'tableName'\n    });\n\n    if (!instanceTable) {\n      // Do nothing when model is not available\n      return;\n    }\n\n    const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : \"\".concat(options.schema, \"_\")) + tableName;\n    const keys = Object.keys(instanceTable.rawAttributes);\n    const keyLen = keys.length;\n\n    for (let i = 0; i < keyLen; i++) {\n      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);\n        options.supportsSearchPath = false;\n        promises.push(this.sequelize.query(sql, { ...options,\n          raw: true\n        }));\n      }\n    }\n\n    await Promise.all(promises);\n  }\n\n}\n\nexports.PostgresQueryInterface = PostgresQueryInterface;","map":null,"metadata":{},"sourceType":"script"}