{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst DataTypes = require('../../data-types');\n\nconst TableHints = require('../../table-hints');\n\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst randomBytes = require('crypto').randomBytes;\n\nconst semver = require('semver');\n\nconst Op = require('../../operators');\n/* istanbul ignore next */\n\n\nconst throwMethodUndefined = function (methodName) {\n  throw new Error(\"The method \\\"\".concat(methodName, \"\\\" is not defined! Please add it to your sql dialect.\"));\n};\n\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      collate: null,\n      ...options\n    };\n    const collation = options.collate ? \"COLLATE \".concat(this.escape(options.collate)) : '';\n    return ['IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')', 'BEGIN', 'CREATE DATABASE', this.quoteIdentifier(databaseName), \"\".concat(collation, \";\"), 'END;'].join(' ');\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return ['IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')', 'BEGIN', 'DROP DATABASE', this.quoteIdentifier(databaseName), ';', 'END;'].join(' ');\n  }\n\n  createSchema(schema) {\n    return ['IF NOT EXISTS (SELECT schema_name', 'FROM information_schema.schemata', 'WHERE schema_name =', wrapSingleQuote(schema), ')', 'BEGIN', \"EXEC sp_executesql N'CREATE SCHEMA\", this.quoteIdentifier(schema), \";'\", 'END;'].join(' ');\n  }\n\n  dropSchema(schema) {\n    // Mimics Postgres CASCADE, will drop objects belonging to the schema\n    const quotedSchema = wrapSingleQuote(schema);\n    return ['IF EXISTS (SELECT schema_name', 'FROM information_schema.schemata', 'WHERE schema_name =', quotedSchema, ')', 'BEGIN', 'DECLARE @id INT, @ms_sql NVARCHAR(2000);', 'DECLARE @cascade TABLE (', 'id INT NOT NULL IDENTITY PRIMARY KEY,', 'ms_sql NVARCHAR(2000) NOT NULL );', 'INSERT INTO @cascade ( ms_sql )', \"SELECT CASE WHEN o.type IN ('F','PK')\", \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\", \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\", 'FROM sys.objects o', 'JOIN sys.schemas s on o.schema_id = s.schema_id', 'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id', \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema, 'ORDER BY o.type ASC;', 'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;', 'WHILE @id IS NOT NULL', 'BEGIN', 'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY', 'BEGIN CATCH BREAK; THROW; END CATCH;', 'DELETE FROM @cascade WHERE id = @id;', 'SELECT @id = NULL, @ms_sql = NULL;', 'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;', 'END', \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\", 'END;'].join(' ');\n  }\n\n  showSchemasQuery() {\n    return ['SELECT \"name\" as \"schema_name\" FROM sys.schemas as s', 'WHERE \"s\".\"name\" NOT IN (', \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\", ')', 'AND', '\"s\".\"name\" NOT LIKE', \"'db_%'\"].join(' ');\n  }\n\n  versionQuery() {\n    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch\n    return ['DECLARE @ms_ver NVARCHAR(20);', \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\", \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"].join(' ');\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n          foreignKeys = {},\n          attributesClauseParts = [];\n    let commentStr = '';\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes('COMMENT ')) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace('COMMENT', '').trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr); // remove comment related substring from dataType\n\n          dataType = commentMatch[1];\n        }\n\n        if (dataType.includes('PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes('REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1].replace('PRIMARY KEY', '')));\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType.replace('PRIMARY KEY', '')));\n          }\n        } else if (dataType.includes('REFERENCES')) {\n          // MSSQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1]));\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType));\n        }\n      }\n    }\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = \"uniq_\".concat(tableName, \"_\").concat(columns.fields.join('_'));\n          }\n\n          attributesClauseParts.push(\"CONSTRAINT \".concat(this.quoteIdentifier(indexName), \" UNIQUE (\").concat(columns.fields.map(field => this.quoteIdentifier(field)).join(', '), \")\"));\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClauseParts.push(\"PRIMARY KEY (\".concat(pkString, \")\"));\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClauseParts.push(\"FOREIGN KEY (\".concat(this.quoteIdentifier(fkey), \") \").concat(foreignKeys[fkey]));\n      }\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\"IF OBJECT_ID('\".concat(quotedTableName, \"', 'U') IS NULL\"), \"CREATE TABLE \".concat(quotedTableName, \" (\").concat(attributesClauseParts.join(', '), \")\"), ';', commentStr]);\n  }\n\n  describeTableQuery(tableName, schema) {\n    let sql = ['SELECT', \"c.COLUMN_NAME AS 'Name',\", \"c.DATA_TYPE AS 'Type',\", \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\", \"c.IS_NULLABLE as 'IsNull',\", \"COLUMN_DEFAULT AS 'Default',\", \"pk.CONSTRAINT_TYPE AS 'Constraint',\", \"COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\", \"CAST(prop.value AS NVARCHAR) AS 'Comment'\", 'FROM', 'INFORMATION_SCHEMA.TABLES t', 'INNER JOIN', 'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA', 'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ', 'cu.column_name, tc.CONSTRAINT_TYPE ', 'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ', 'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ', 'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ', 'and tc.constraint_name=cu.constraint_name ', 'and tc.CONSTRAINT_TYPE=\\'PRIMARY KEY\\') pk ', 'ON pk.table_schema=c.table_schema ', 'AND pk.table_name=c.table_name ', 'AND pk.column_name=c.column_name ', 'INNER JOIN sys.columns AS sc', \"ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name\", 'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id', 'AND prop.minor_id = sc.column_id', \"AND prop.name = 'MS_Description'\", 'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)].join(' ');\n\n    if (schema) {\n      sql += \"AND t.TABLE_SCHEMA =\".concat(wrapSingleQuote(schema));\n    }\n\n    return sql;\n  }\n\n  renameTableQuery(before, after) {\n    return \"EXEC sp_rename \".concat(this.quoteTable(before), \", \").concat(this.quoteTable(after), \";\");\n  }\n\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n\n  dropTableQuery(tableName) {\n    const quoteTbl = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\"IF OBJECT_ID('\".concat(quoteTbl, \"', 'U') IS NOT NULL\"), 'DROP TABLE', quoteTbl, ';']);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery\n    //        but instead we need to pass the key along as the field here\n    dataType.field = key;\n    let commentStr = '';\n\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key); // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key\n      // is present. This is needed for createTable statement where that part is extracted with regex.\n      // Here we can intercept the object and remove comment property since we have the original object.\n\n      delete dataType['comment'];\n    }\n\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(table), 'ADD', this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      context: 'addColumn'\n    }), ';', commentStr]);\n  }\n\n  commentTemplate(comment, table, column) {\n    return ' EXEC sp_addextendedproperty ' + \"@name = N'MS_Description', @value = \".concat(this.escape(comment), \", \") + '@level0type = N\\'Schema\\', @level0name = \\'dbo\\', ' + \"@level1type = N'Table', @level1name = \".concat(this.quoteIdentifier(table), \", \") + \"@level2type = N'Column', @level2name = \".concat(this.quoteIdentifier(column), \";\");\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), 'DROP COLUMN', this.quoteIdentifier(attributeName), ';']);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [],\n          constraintString = [];\n    let commentString = '';\n\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n\n      if (definition.includes('COMMENT ')) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace('COMMENT', '').trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName); // remove comment related substring from dataType\n\n        definition = commentMatch[1];\n      }\n\n      if (definition.includes('REFERENCES')) {\n        constraintString.push(\"FOREIGN KEY (\".concat(quotedAttrName, \") \").concat(definition.replace(/.+?(?=REFERENCES)/, '')));\n      } else {\n        attrString.push(\"\".concat(quotedAttrName, \" \").concat(definition));\n      }\n    }\n\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), attrString.length && \"ALTER COLUMN \".concat(attrString.join(', ')), constraintString.length && \"ADD \".concat(constraintString.join(', ')), ';', commentString]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return Utils.joinSQLFragments(['EXEC sp_rename', \"'\".concat(this.quoteTable(tableName), \".\").concat(attrBefore, \"',\"), \"'\".concat(newName, \"',\"), \"'COLUMN'\", ';']);\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n    let needIdentityInsertWrapper = false,\n        outputFragment = '';\n\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n      outputFragment = returnValues.outputFragment;\n    }\n\n    const emptyQuery = \"INSERT INTO \".concat(quotedTable).concat(outputFragment, \" DEFAULT VALUES\");\n    attrValueHashes.forEach(attrValueHash => {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      } // normal case\n\n\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement) return;\n          allAttributes.push(key);\n        }\n      });\n    });\n\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach(attrValueHash => {\n        tuples.push(\"(\".concat(allAttributes.map(key => this.escape(attrValueHash[key])).join(','), \")\"));\n      });\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n      allQueries.push(tupleStr => \"INSERT INTO \".concat(quotedTable, \" (\").concat(quotedAttributes, \")\").concat(outputFragment, \" VALUES \").concat(tupleStr, \";\"));\n    }\n\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map(v => typeof v === 'string' ? v : v(tupleStr)).join(';');\n\n      if (needIdentityInsertWrapper) {\n        generatedQuery = \"SET IDENTITY_INSERT \".concat(quotedTable, \" ON; \").concat(generatedQuery, \"; SET IDENTITY_INSERT \").concat(quotedTable, \" OFF;\");\n      }\n\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n\n    return commands.join(';');\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n\n    if (options.limit) {\n      const updateArgs = \"UPDATE TOP(\".concat(this.escape(options.limit), \")\");\n      sql.query = sql.query.replace('UPDATE', updateArgs);\n    }\n\n    return sql;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(\"\".concat(tableName, \"_target\"));\n    const sourceTableAlias = this.quoteTable(\"\".concat(tableName, \"_source\"));\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false; //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    } //Add unique indexes defined by indexes option to uniqueAttrs\n\n\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');\n    const sourceTableQuery = \"VALUES(\".concat(insertValuesEscaped, \")\"); //Virtual Table\n\n    let joinCondition; //IDENTITY_INSERT Condition\n\n    identityAttrs.forEach(key => {\n      if (updateValues[key] && updateValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n        /*\n         * IDENTITY_INSERT Column Cannot be updated, only inserted\n         * http://stackoverflow.com/a/30176254/2254360\n         */\n      }\n    }); //Filter NULL Clauses\n\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n\n      for (const key in clause) {\n        if (typeof clause[key] === 'undefined' || clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n\n      return valid;\n    });\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return \"\".concat(targetTableAlias, \".\").concat(key, \" = \").concat(sourceTableAlias, \".\").concat(key);\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n          break;\n        }\n      }\n\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n      }\n    } // Remove the IDENTITY_INSERT Column from update\n\n\n    const updateSnippet = updateKeys.filter(key => !identityAttrs.includes(key)).map(key => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return \"\".concat(targetTableAlias, \".\").concat(key, \" = \").concat(value);\n    }).join(', ');\n    const insertSnippet = \"(\".concat(insertKeysQuoted, \") VALUES(\").concat(insertValuesEscaped, \")\");\n    let query = \"MERGE INTO \".concat(tableNameQuoted, \" WITH(HOLDLOCK) AS \").concat(targetTableAlias, \" USING (\").concat(sourceTableQuery, \") AS \").concat(sourceTableAlias, \"(\").concat(insertKeysQuoted, \") ON \").concat(joinCondition);\n    query += \" WHEN MATCHED THEN UPDATE SET \".concat(updateSnippet, \" WHEN NOT MATCHED THEN INSERT \").concat(insertSnippet, \" OUTPUT $action, INSERTED.*;\");\n\n    if (needIdentityInsertWrapper) {\n      query = \"SET IDENTITY_INSERT \".concat(tableNameQuoted, \" ON; \").concat(query, \" SET IDENTITY_INSERT \").concat(tableNameQuoted, \" OFF;\");\n    }\n\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return \"TRUNCATE TABLE \".concat(this.quoteTable(tableName));\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const whereClause = this.getWhereConditions(where, null, model, options);\n    return Utils.joinSQLFragments(['DELETE', options.limit && \"TOP(\".concat(this.escape(options.limit), \")\"), 'FROM', table, whereClause && \"WHERE \".concat(whereClause), ';', 'SELECT @@ROWCOUNT AS AFFECTEDROWS', ';']);\n  }\n\n  showIndexesQuery(tableName) {\n    return \"EXEC sys.sp_helpindex @objname = N'\".concat(this.quoteTable(tableName), \"';\");\n  }\n\n  showConstraintsQuery(tableName) {\n    return \"EXEC sp_helpconstraint @objname = \".concat(this.escape(this.quoteTable(tableName)), \";\");\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(\"\".concat(tableName, \"_\").concat(indexNameOrAttributes.join('_')));\n    }\n\n    return \"DROP INDEX \".concat(this.quoteIdentifiers(indexName), \" ON \").concat(this.quoteIdentifiers(tableName));\n  }\n\n  attributeToSQL(attribute) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    } // handle self referential constraints\n\n\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log('MSSQL does not support self referencial constraints, ' + 'we will remove it but we recommend restructuring your query');\n        attribute.onDelete = '';\n        attribute.onUpdate = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values; // enums are a special case\n\n      template = attribute.type.toSql();\n      template += \" CHECK (\".concat(this.quoteIdentifier(attribute.field), \" IN(\").concat(attribute.values.map(value => {\n        return this.escape(value);\n      }).join(', '), \"))\");\n      return template;\n    }\n\n    template = attribute.type.toString();\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' IDENTITY(1,1)';\n    } // Blobs/texts cannot have a defaultValue\n\n\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += \" DEFAULT \".concat(this.escape(attribute.defaultValue));\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      template += \" REFERENCES \".concat(this.quoteTable(attribute.references.model));\n\n      if (attribute.references.key) {\n        template += \" (\".concat(this.quoteIdentifier(attribute.references.key), \")\");\n      } else {\n        template += \" (\".concat(this.quoteIdentifier('id'), \")\");\n      }\n\n      if (attribute.onDelete) {\n        template += \" ON DELETE \".concat(attribute.onDelete.toUpperCase());\n      }\n\n      if (attribute.onUpdate) {\n        template += \" ON UPDATE \".concat(attribute.onUpdate.toUpperCase());\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      template += \" COMMENT \".concat(attribute.comment);\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {},\n          existingConstraints = [];\n    let key, attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(attribute.references.model.toString()); // NOTE: this really just disables cascading updates for all\n          //       definitions. Can be made more robust to support the\n          //       few cases where MSSQL actually supports them\n\n          attribute.onUpdate = '';\n        }\n      }\n\n      if (key && !attribute.field) attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n  /**\n   * Generate common SQL prefix for ForeignKeysQuery.\n   *\n   * @param {string} catalogName\n   * @returns {string}\n   */\n\n\n  _getForeignKeysQueryPrefix(catalogName) {\n    return \"\".concat('SELECT ' + 'constraint_name = OBJ.NAME, ' + 'constraintName = OBJ.NAME, ').concat(catalogName ? \"constraintCatalog = '\".concat(catalogName, \"', \") : '', \"constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), \") + 'tableName = TB.NAME, ' + \"tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), \".concat(catalogName ? \"tableCatalog = '\".concat(catalogName, \"', \") : '', \"columnName = COL.NAME, \") + \"referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), \".concat(catalogName ? \"referencedCatalog = '\".concat(catalogName, \"', \") : '', \"referencedTableName = RTB.NAME, \") + 'referencedColumnName = RCOL.NAME ' + 'FROM sys.foreign_key_columns FKC ' + 'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' + 'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' + 'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' + 'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' + 'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';\n  }\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * @param {string|object} table\n   * @param {string} catalogName database name\n   * @returns {string}\n   */\n\n\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = \"\".concat(this._getForeignKeysQueryPrefix(catalogName), \" WHERE TB.NAME =\").concat(wrapSingleQuote(tableName));\n\n    if (table.schema) {\n      sql += \" AND SCHEMA_NAME(TB.SCHEMA_ID) =\".concat(wrapSingleQuote(table.schema));\n    }\n\n    return sql;\n  }\n\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([this._getForeignKeysQueryPrefix(), 'WHERE', \"TB.NAME =\".concat(wrapSingleQuote(tableName)), 'AND', \"COL.NAME =\".concat(wrapSingleQuote(attributeName)), table.schema && \"AND SCHEMA_NAME(TB.SCHEMA_ID) =\".concat(wrapSingleQuote(table.schema))]);\n  }\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return Utils.joinSQLFragments(['SELECT K.TABLE_NAME AS tableName,', 'K.COLUMN_NAME AS columnName,', 'K.CONSTRAINT_NAME AS constraintName', 'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C', 'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K', 'ON C.TABLE_NAME = K.TABLE_NAME', 'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG', 'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA', 'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME', 'WHERE C.CONSTRAINT_TYPE = \\'PRIMARY KEY\\'', \"AND K.COLUMN_NAME = \".concat(wrapSingleQuote(attributeName)), \"AND K.TABLE_NAME = \".concat(tableName), ';']);\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), 'DROP', this.quoteIdentifier(foreignKey)]);\n  }\n\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return Utils.joinSQLFragments(['SELECT name FROM sys.default_constraints', \"WHERE PARENT_OBJECT_ID = OBJECT_ID('\".concat(quotedTable, \"', 'U')\"), \"AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('\".concat(attributeName, \"')\"), \"AND object_id = OBJECT_ID('\".concat(quotedTable, \"', 'U'))\"), ';']);\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), 'DROP CONSTRAINT', this.quoteIdentifier(constraintName), ';']);\n  }\n\n  setIsolationLevelQuery() {}\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return \"SAVE TRANSACTION \".concat(this.quoteIdentifier(transaction.name), \";\");\n    }\n\n    return 'BEGIN TRANSACTION;';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return \"ROLLBACK TRANSACTION \".concat(this.quoteIdentifier(transaction.name), \";\");\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    this._throwOnEmptyAttributes(attributes, {\n      modelName: model && model.name,\n      as: mainTableAs\n    });\n\n    const dbVersion = this.sequelize.options.databaseVersion;\n    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, '11.0.0');\n\n    if (isSQLServer2008 && options.offset) {\n      // For earlier versions of SQL server, we need to nest several queries\n      // in order to emulate the OFFSET behavior.\n      //\n      // 1. The outermost query selects all items from the inner query block.\n      //    This is due to a limitation in SQL server with the use of computed\n      //    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.\n      // 2. The next query handles the LIMIT and OFFSET behavior by getting\n      //    the TOP N rows of the query where the row number is > OFFSET\n      // 3. The innermost query is the actual set we want information from\n      const offset = options.offset || 0;\n      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      let orders = {\n        mainQueryOrder: []\n      };\n\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n\n      if (orders.mainQueryOrder.length === 0) {\n        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n      }\n\n      const tmpTable = mainTableAs || 'OffsetTable';\n      return Utils.joinSQLFragments(['SELECT TOP 100 PERCENT', attributes.join(', '), 'FROM (', ['SELECT', options.limit && \"TOP \".concat(options.limit), '* FROM (', ['SELECT ROW_NUMBER() OVER (', ['ORDER BY', orders.mainQueryOrder.join(', ')], \") as row_num, * FROM \".concat(tables, \" AS \").concat(tmpTable), where && \"WHERE \".concat(where)], \") AS \".concat(tmpTable, \" WHERE row_num > \").concat(offset)], \") AS \".concat(tmpTable)]);\n    }\n\n    return Utils.joinSQLFragments(['SELECT', isSQLServer2008 && options.limit && \"TOP \".concat(options.limit), attributes.join(', '), \"FROM \".concat(tables), mainTableAs && \"AS \".concat(mainTableAs), options.tableHint && TableHints[options.tableHint] && \"WITH (\".concat(TableHints[options.tableHint], \")\")]);\n  }\n\n  addLimitAndOffset(options, model) {\n    // Skip handling of limit and offset as postfixes for older SQL Server versions\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      return '';\n    }\n\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === undefined ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;\n    let fragment = '';\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      if (!options.order || !options.order.length || options.include && !orders.subQueryOrder.length) {\n        const tablePkFragment = \"\".concat(this.quoteTable(options.tableAs || model.name), \".\").concat(this.quoteIdentifier(model.primaryKeyField));\n\n        if (!options.order || !options.order.length) {\n          fragment += \" ORDER BY \".concat(tablePkFragment);\n        } else {\n          const orderFieldNames = _.map(options.order, order => order[0]);\n\n          const primaryKeyFieldAlreadyPresent = _.includes(orderFieldNames, model.primaryKeyField);\n\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n            fragment += tablePkFragment;\n          }\n        }\n      }\n\n      if (options.offset || options.limit) {\n        fragment += \" OFFSET \".concat(this.escape(offset), \" ROWS\");\n      }\n\n      if (options.limit) {\n        fragment += \" FETCH NEXT \".concat(this.escape(options.limit), \" ROWS ONLY\");\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n} // private methods\n\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\n\nmodule.exports = MSSQLQueryGenerator;","map":null,"metadata":{},"sourceType":"script"}