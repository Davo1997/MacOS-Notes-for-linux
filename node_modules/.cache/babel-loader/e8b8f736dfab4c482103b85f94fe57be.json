{"ast":null,"code":"'use strict';\n\nconst Types = require('../constants/types.js');\n\nconst Charsets = require('../constants/charsets.js');\n\nconst helpers = require('../helpers');\n\nconst genFunc = require('generate-function');\n\nconst parserCache = require('./parser_cache.js');\n\nconst typeNames = [];\n\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\n\nfunction readCodeFor(type, charset, encodingExpr, config, options) {\n  const supportBigNumbers = options.supportBigNumbers || config.supportBigNumbers;\n  const bigNumberStrings = options.bigNumberStrings || config.bigNumberStrings;\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n\n  switch (type) {\n    case Types.TINY:\n    case Types.SHORT:\n    case Types.LONG:\n    case Types.INT24:\n    case Types.YEAR:\n      return 'packet.parseLengthCodedIntNoBigCheck()';\n\n    case Types.LONGLONG:\n      if (supportBigNumbers && bigNumberStrings) {\n        return 'packet.parseLengthCodedIntString()';\n      }\n\n      return \"packet.parseLengthCodedInt(\".concat(supportBigNumbers, \")\");\n\n    case Types.FLOAT:\n    case Types.DOUBLE:\n      return 'packet.parseLengthCodedFloat()';\n\n    case Types.NULL:\n      return 'packet.readLengthCodedNumber()';\n\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return 'packet.parseLengthCodedFloat()';\n      }\n\n      return 'packet.readLengthCodedString(\"ascii\")';\n\n    case Types.DATE:\n      if (helpers.typeMatch(type, dateStrings, Types)) {\n        return 'packet.readLengthCodedString(\"ascii\")';\n      }\n\n      return \"packet.parseDate('\".concat(timezone, \"')\");\n\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n      if (helpers.typeMatch(type, dateStrings, Types)) {\n        return 'packet.readLengthCodedString(\"ascii\")';\n      }\n\n      return \"packet.parseDateTime('\".concat(timezone, \"')\");\n\n    case Types.TIME:\n      return 'packet.readLengthCodedString(\"ascii\")';\n\n    case Types.GEOMETRY:\n      return 'packet.parseGeometryValue()';\n\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return 'JSON.parse(packet.readLengthCodedString(\"utf8\"))';\n\n    default:\n      if (charset === Charsets.BINARY) {\n        return 'packet.readLengthCodedBuffer()';\n      }\n\n      return \"packet.readLengthCodedString(\".concat(encodingExpr, \")\");\n  }\n}\n\nfunction compile(fields, options, config) {\n  // node-mysql typeCast compatibility wrapper\n  // see https://github.com/mysqljs/mysql/blob/96fdd0566b654436624e2375c7b6604b1f50f825/lib/protocol/packets/Field.js\n  function wrap(field, type, packet, encoding) {\n    return {\n      type: type,\n      length: field.columnLength,\n      db: field.schema,\n      table: field.table,\n      name: field.name,\n      string: function () {\n        return packet.readLengthCodedString(encoding);\n      },\n      buffer: function () {\n        return packet.readLengthCodedBuffer();\n      },\n      geometry: function () {\n        return packet.parseGeometryValue();\n      }\n    };\n  } // use global typeCast if current query doesn't specify one\n\n\n  if (typeof config.typeCast === 'function' && typeof options.typeCast !== 'function') {\n    options.typeCast = config.typeCast;\n  }\n\n  const parserFn = genFunc();\n  let i = 0;\n  /* eslint-disable no-trailing-spaces */\n\n  /* eslint-disable no-spaced-func */\n\n  /* eslint-disable no-unexpected-multiline */\n\n  parserFn('(function () {')('return function TextRow(packet, fields, options, CharsetToEncoding) {');\n\n  if (options.rowsAsArray) {\n    parserFn(\"const result = new Array(\".concat(fields.length, \")\"));\n  }\n\n  if (typeof options.typeCast === 'function') {\n    parserFn(\"const wrap = \".concat(wrap.toString()));\n  }\n\n  const resultTables = {};\n  let resultTablesArray = [];\n\n  if (options.nestTables === true) {\n    for (i = 0; i < fields.length; i++) {\n      resultTables[fields[i].table] = 1;\n    }\n\n    resultTablesArray = Object.keys(resultTables);\n\n    for (i = 0; i < resultTablesArray.length; i++) {\n      parserFn(\"this[\".concat(helpers.srcEscape(resultTablesArray[i]), \"] = {};\"));\n    }\n  }\n\n  let lvalue = '';\n  let fieldName = '';\n\n  for (i = 0; i < fields.length; i++) {\n    fieldName = helpers.srcEscape(fields[i].name);\n    parserFn(\"// \".concat(fieldName, \": \").concat(typeNames[fields[i].columnType]));\n\n    if (typeof options.nestTables === 'string') {\n      lvalue = \"this[\".concat(helpers.srcEscape(fields[i].table + options.nestTables + fields[i].name), \"]\");\n    } else if (options.nestTables === true) {\n      lvalue = \"this[\".concat(helpers.srcEscape(fields[i].table), \"][\").concat(fieldName, \"]\");\n    } else if (options.rowsAsArray) {\n      lvalue = \"result[\".concat(i.toString(10), \"]\");\n    } else {\n      lvalue = \"this[\".concat(fieldName, \"]\");\n    }\n\n    const encodingExpr = \"CharsetToEncoding[fields[\".concat(i, \"].characterSet]\");\n    const readCode = readCodeFor(fields[i].columnType, fields[i].characterSet, encodingExpr, config, options);\n\n    if (typeof options.typeCast === 'function') {\n      parserFn(\"\".concat(lvalue, \" = options.typeCast(wrap(fields[\").concat(i, \"], \").concat(helpers.srcEscape(typeNames[fields[i].columnType]), \", packet, \").concat(encodingExpr, \"), function() { return \").concat(readCode, \";})\"));\n    } else if (options.typeCast === false) {\n      parserFn(\"\".concat(lvalue, \" = packet.readLengthCodedBuffer();\"));\n    } else {\n      parserFn(\"\".concat(lvalue, \" = \").concat(readCode, \";\"));\n    }\n  }\n\n  if (options.rowsAsArray) {\n    parserFn('return result;');\n  }\n\n  parserFn('};')('})()');\n  /* eslint-enable no-trailing-spaces */\n\n  /* eslint-enable no-spaced-func */\n\n  /* eslint-enable no-unexpected-multiline */\n\n  if (config.debug) {\n    helpers.printDebugWithCode('Compiled text protocol row parser', parserFn.toString());\n  }\n\n  return parserFn.toFunction();\n}\n\nfunction getTextParser(fields, options, config) {\n  return parserCache.getParser('text', fields, options, config, compile);\n}\n\nmodule.exports = getTextParser;","map":null,"metadata":{},"sourceType":"script"}