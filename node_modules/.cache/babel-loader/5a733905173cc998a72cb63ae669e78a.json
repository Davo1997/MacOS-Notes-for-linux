{"ast":null,"code":"'use strict';\n\nconst ErrorCodeToName = require('../constants/errors.js');\n\nconst NativeBuffer = require('buffer').Buffer;\n\nconst Long = require('long');\n\nconst StringParser = require('../parsers/string.js');\n\nconst INVALID_DATE = new Date(NaN); // this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\n\nconst pad = '000000000000';\n\nfunction leftPad(num, value) {\n  const s = value.toString(); // if we don't need to pad\n\n  if (s.length >= num) {\n    return s;\n  }\n\n  return (pad + s).slice(-num);\n} // The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\n\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0); // TODO: handle E notation\n\nconst dot = '.'.charCodeAt(0);\nconst exponent = 'e'.charCodeAt(0);\nconst exponentCapital = 'E'.charCodeAt(0);\n\nclass Packet {\n  constructor(id, buffer, start, end) {\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  } // ==============================\n  // readers\n  // ==============================\n\n\n  reset() {\n    this.offset = this.start + 4;\n  }\n\n  length() {\n    return this.end - this.start;\n  }\n\n  slice() {\n    return this.buffer.slice(this.start, this.end);\n  }\n\n  dump() {\n    // eslint-disable-next-line no-console\n    console.log([this.buffer.asciiSlice(this.start, this.end)], this.buffer.slice(this.start, this.end), this.length(), this.sequenceId);\n  }\n\n  haveMoreData() {\n    return this.end > this.offset;\n  }\n\n  skip(num) {\n    this.offset += num;\n  }\n\n  readInt8() {\n    return this.buffer[this.offset++];\n  }\n\n  readInt16() {\n    this.offset += 2;\n    return this.buffer.readUInt16LE(this.offset - 2);\n  }\n\n  readInt24() {\n    return this.readInt16() + (this.readInt8() << 16);\n  }\n\n  readInt32() {\n    this.offset += 4;\n    return this.buffer.readUInt32LE(this.offset - 4);\n  }\n\n  readSInt8() {\n    return this.buffer.readInt8(this.offset++);\n  }\n\n  readSInt16() {\n    this.offset += 2;\n    return this.buffer.readInt16LE(this.offset - 2);\n  }\n\n  readSInt32() {\n    this.offset += 4;\n    return this.buffer.readInt32LE(this.offset - 4);\n  }\n\n  readInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const l = new Long(word0, word1, true);\n    return l.toNumber();\n  }\n\n  readSInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n\n    if (!(word1 & 0x80000000)) {\n      return word0 + 0x100000000 * word1;\n    }\n\n    const l = new Long(word0, word1, false);\n    return l.toNumber();\n  }\n\n  readInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, true);\n    return res.toString();\n  }\n\n  readSInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, false);\n    return res.toString();\n  }\n\n  readInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, true);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  readSInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, false);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  isEOF() {\n    return this.buffer[this.offset] === 0xfe && this.length() < 13;\n  }\n\n  eofStatusFlags() {\n    return this.buffer.readInt16LE(this.offset + 3);\n  }\n\n  eofWarningCount() {\n    return this.buffer.readInt16LE(this.offset + 1);\n  }\n\n  readLengthCodedNumber(bigNumberStrings, signed) {\n    const byte1 = this.buffer[this.offset++];\n\n    if (byte1 < 251) {\n      return byte1;\n    }\n\n    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n  }\n\n  readLengthCodedNumberSigned(bigNumberStrings) {\n    return this.readLengthCodedNumber(bigNumberStrings, true);\n  }\n\n  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n    let word0, word1;\n    let res;\n\n    if (tag === 0xfb) {\n      return null;\n    }\n\n    if (tag === 0xfc) {\n      return this.readInt8() + (this.readInt8() << 8);\n    }\n\n    if (tag === 0xfd) {\n      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n    }\n\n    if (tag === 0xfe) {\n      // TODO: check version\n      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n      word0 = this.readInt32();\n      word1 = this.readInt32();\n\n      if (word1 === 0) {\n        return word0; // don't convert to float if possible\n      }\n\n      if (word1 < 2097152) {\n        // max exact float point int, 2^52 / 2^32\n        return word1 * 0x100000000 + word0;\n      }\n\n      res = new Long(word0, word1, !signed); // Long need unsigned\n\n      const resNumber = res.toNumber();\n      const resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return bigNumberStrings ? resString : res;\n    } // eslint-disable-next-line no-console\n\n\n    console.trace();\n    throw new Error(\"Should not reach here: \".concat(tag));\n  }\n\n  readFloat() {\n    const res = this.buffer.readFloatLE(this.offset);\n    this.offset += 4;\n    return res;\n  }\n\n  readDouble() {\n    const res = this.buffer.readDoubleLE(this.offset);\n    this.offset += 8;\n    return res;\n  }\n\n  readBuffer(len) {\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n\n    this.offset += len;\n    return this.buffer.slice(this.offset - len, this.offset);\n  } // DATE, DATETIME and TIMESTAMP\n\n\n  readDateTime(timezone) {\n    if (!timezone || timezone === 'Z' || timezone === 'local') {\n      const length = this.readInt8();\n\n      if (length === 0xfb) {\n        return null;\n      }\n\n      let y = 0;\n      let m = 0;\n      let d = 0;\n      let H = 0;\n      let M = 0;\n      let S = 0;\n      let ms = 0;\n\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n      }\n\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n\n      if (length > 10) {\n        ms = this.readInt32() / 1000;\n      }\n\n      if (y + m + d + H + M + S + ms === 0) {\n        return INVALID_DATE;\n      }\n\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n      }\n\n      return new Date(y, m - 1, d, H, M, S, ms);\n    }\n\n    let str = this.readDateTimeString(6, 'T');\n\n    if (str.length === 10) {\n      str += 'T00:00:00';\n    }\n\n    return new Date(str + timezone);\n  }\n\n  readDateTimeString(decimals, timeSep) {\n    const length = this.readInt8();\n    let y = 0;\n    let m = 0;\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    let str;\n\n    if (length > 3) {\n      y = this.readInt16();\n      m = this.readInt8();\n      d = this.readInt8();\n      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n    }\n\n    if (length > 6) {\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n      str += \"\".concat(timeSep || ' ').concat([leftPad(2, H), leftPad(2, M), leftPad(2, S)].join(':'));\n    }\n\n    if (length > 10) {\n      ms = this.readInt32();\n      str += '.';\n\n      if (decimals) {\n        ms = leftPad(6, ms);\n\n        if (ms.length > decimals) {\n          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n        }\n      }\n\n      str += ms;\n    }\n\n    return str;\n  } // TIME - value as a string, Can be negative\n\n\n  readTimeString(convertTtoMs) {\n    const length = this.readInt8();\n\n    if (length === 0) {\n      return '00:00:00';\n    }\n\n    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n\n    if (length > 6) {\n      d = this.readInt32();\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n    }\n\n    if (length > 10) {\n      ms = this.readInt32();\n    }\n\n    if (convertTtoMs) {\n      H += d * 24;\n      M += H * 60;\n      S += M * 60;\n      ms += S * 1000;\n      ms *= sign;\n      return ms;\n    }\n\n    return (sign === -1 ? '-' : '') + [d ? d * 24 + H : H, leftPad(2, M), leftPad(2, S)].join(':') + (ms ? \".\".concat(ms) : '');\n  }\n\n  readLengthCodedString(encoding) {\n    const len = this.readLengthCodedNumber(); // TODO: check manually first byte here to avoid polymorphic return type?\n\n    if (len === null) {\n      return null;\n    }\n\n    this.offset += len; // TODO: Use characterSetCode to get proper encoding\n    // https://github.com/sidorares/node-mysql2/pull/374\n\n    return StringParser.decode(this.buffer.slice(this.offset - len, this.offset), encoding);\n  }\n\n  readLengthCodedBuffer() {\n    const len = this.readLengthCodedNumber();\n\n    if (len === null) {\n      return null;\n    }\n\n    return this.readBuffer(len);\n  }\n\n  readNullTerminatedString(encoding) {\n    const start = this.offset;\n    let end = this.offset;\n\n    while (this.buffer[end]) {\n      end = end + 1; // TODO: handle OOB check\n    }\n\n    this.offset = end + 1;\n    return StringParser.decode(this.buffer.slice(start, end), encoding);\n  } // TODO reuse?\n\n\n  readString(len, encoding) {\n    if (typeof len === 'string' && typeof encoding === 'undefined') {\n      encoding = len;\n      len = undefined;\n    }\n\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n\n    this.offset += len;\n    return StringParser.decode(this.buffer.slice(this.offset - len, this.offset), encoding);\n  }\n\n  parseInt(len, supportBigNumbers) {\n    if (len === null) {\n      return null;\n    }\n\n    if (len >= 14 && !supportBigNumbers) {\n      const s = this.buffer.toString('ascii', this.offset, this.offset + len);\n      this.offset += len;\n      return Number(s);\n    }\n\n    let result = 0;\n    const start = this.offset;\n    const end = this.offset + len;\n    let sign = 1;\n\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    } // max precise int is 9007199254740992\n\n\n    let str;\n    const numDigits = end - this.offset;\n\n    if (supportBigNumbers) {\n      if (numDigits >= 15) {\n        str = this.readString(end - this.offset, 'binary');\n        result = parseInt(str, 10);\n\n        if (result.toString() === str) {\n          return sign * result;\n        }\n\n        return sign === -1 ? \"-\".concat(str) : str;\n      }\n\n      if (numDigits > 16) {\n        str = this.readString(end - this.offset);\n        return sign === -1 ? \"-\".concat(str) : str;\n      }\n    }\n\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n\n    const num = result * sign;\n\n    if (!supportBigNumbers) {\n      return num;\n    }\n\n    str = this.buffer.toString('ascii', start, end);\n\n    if (num.toString() === str) {\n      return num;\n    }\n\n    return str;\n  } // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n  // different from what you would get from Number(inputNumberAsString)\n  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n\n\n  parseIntNoBigCheck(len) {\n    if (len === null) {\n      return null;\n    }\n\n    let result = 0;\n    const end = this.offset + len;\n    let sign = 1;\n\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n\n    return result * sign;\n  } // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n\n\n  parseGeometryValue() {\n    const buffer = this.readLengthCodedBuffer();\n    let offset = 4;\n\n    if (buffer === null || !buffer.length) {\n      return null;\n    }\n\n    function parseGeometry() {\n      let x, y, i, j, numPoints, line;\n      let result = null;\n      const byteOrder = buffer.readUInt8(offset);\n      offset += 1;\n      const wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n      offset += 4;\n\n      switch (wkbType) {\n        case 1:\n          // WKBPoint\n          x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n          offset += 8;\n          y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n          offset += 8;\n          result = {\n            x: x,\n            y: y\n          };\n          break;\n\n        case 2:\n          // WKBLineString\n          numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n\n          for (i = numPoints; i > 0; i--) {\n            x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            result.push({\n              x: x,\n              y: y\n            });\n          }\n\n          break;\n\n        case 3:\n          // WKBPolygon\n          // eslint-disable-next-line no-case-declarations\n          const numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n\n          for (i = numRings; i > 0; i--) {\n            numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n            offset += 4;\n            line = [];\n\n            for (j = numPoints; j > 0; j--) {\n              x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              line.push({\n                x: x,\n                y: y\n              });\n            }\n\n            result.push(line);\n          }\n\n          break;\n\n        case 4: // WKBMultiPoint\n\n        case 5: // WKBMultiLineString\n\n        case 6: // WKBMultiPolygon\n\n        case 7:\n          // WKBGeometryCollection\n          // eslint-disable-next-line no-case-declarations\n          const num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n\n          for (i = num; i > 0; i--) {\n            result.push(parseGeometry());\n          }\n\n          break;\n      }\n\n      return result;\n    }\n\n    return parseGeometry();\n  }\n\n  parseDate(timezone) {\n    const strLen = this.readLengthCodedNumber();\n\n    if (strLen === null) {\n      return null;\n    }\n\n    if (strLen !== 10) {\n      // we expect only YYYY-MM-DD here.\n      // if for some reason it's not the case return invalid date\n      return new Date(NaN);\n    }\n\n    const y = this.parseInt(4);\n    this.offset++; // -\n\n    const m = this.parseInt(2);\n    this.offset++; // -\n\n    const d = this.parseInt(2);\n\n    if (!timezone || timezone === 'local') {\n      return new Date(y, m - 1, d);\n    }\n\n    if (timezone === 'Z') {\n      return new Date(Date.UTC(y, m - 1, d));\n    }\n\n    return new Date(\"\".concat(leftPad(4, y), \"-\").concat(leftPad(2, m), \"-\").concat(leftPad(2, d), \"T00:00:00\").concat(timezone));\n  }\n\n  parseDateTime(timezone) {\n    const str = this.readLengthCodedString('binary');\n\n    if (str === null) {\n      return null;\n    }\n\n    if (!timezone || timezone === 'local') {\n      return new Date(str);\n    }\n\n    return new Date(\"\".concat(str).concat(timezone));\n  }\n\n  parseFloat(len) {\n    if (len === null) {\n      return null;\n    }\n\n    let result = 0;\n    const end = this.offset + len;\n    let factor = 1;\n    let pastDot = false;\n    let charCode = 0;\n\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      factor = -1;\n    }\n\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      charCode = this.buffer[this.offset];\n\n      if (charCode === dot) {\n        pastDot = true;\n        this.offset++;\n      } else if (charCode === exponent || charCode === exponentCapital) {\n        this.offset++;\n        const exponentValue = this.parseInt(end - this.offset);\n        return result / factor * Math.pow(10, exponentValue);\n      } else {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n\n        if (pastDot) {\n          factor = factor * 10;\n        }\n      }\n    }\n\n    return result / factor;\n  }\n\n  parseLengthCodedIntNoBigCheck() {\n    return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n  }\n\n  parseLengthCodedInt(supportBigNumbers) {\n    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n  }\n\n  parseLengthCodedIntString() {\n    return this.readLengthCodedString('binary');\n  }\n\n  parseLengthCodedFloat() {\n    return this.parseFloat(this.readLengthCodedNumber());\n  }\n\n  peekByte() {\n    return this.buffer[this.offset];\n  } // OxFE is often used as \"Alt\" flag - not ok, not error.\n  // For example, it's first byte of AuthSwitchRequest\n\n\n  isAlt() {\n    return this.peekByte() === 0xfe;\n  }\n\n  isError() {\n    return this.peekByte() === 0xff;\n  }\n\n  asError(encoding) {\n    this.reset();\n    this.readInt8(); // fieldCount\n\n    const errorCode = this.readInt16();\n    let sqlState = '';\n\n    if (this.buffer[this.offset] === 0x23) {\n      this.skip(1);\n      sqlState = this.readBuffer(5).toString();\n    }\n\n    const message = this.readString(undefined, encoding);\n    const err = new Error(message);\n    err.code = ErrorCodeToName[errorCode];\n    err.errno = errorCode;\n    err.sqlState = sqlState;\n    err.sqlMessage = message;\n    return err;\n  }\n\n  writeInt32(n) {\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n  }\n\n  writeInt24(n) {\n    this.writeInt8(n & 0xff);\n    this.writeInt16(n >> 8);\n  }\n\n  writeInt16(n) {\n    this.buffer.writeUInt16LE(n, this.offset);\n    this.offset += 2;\n  }\n\n  writeInt8(n) {\n    this.buffer.writeUInt8(n, this.offset);\n    this.offset++;\n  }\n\n  writeDouble(n) {\n    this.buffer.writeDoubleLE(n, this.offset);\n    this.offset += 8;\n  }\n\n  writeBuffer(b) {\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeNull() {\n    this.buffer[this.offset] = 0xfb;\n    this.offset++;\n  } // TODO: refactor following three?\n\n\n  writeNullTerminatedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n    this.writeInt8(0);\n  }\n\n  writeString(s, encoding) {\n    if (s === null) {\n      this.writeInt8(0xfb);\n      return;\n    }\n\n    if (s.length === 0) {\n      return;\n    } // const bytes = Buffer.byteLength(s, 'utf8');\n    // this.buffer.write(s, this.offset, bytes, 'utf8');\n    // this.offset += bytes;\n\n\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.writeLengthCodedNumber(buf.length);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedBuffer(b) {\n    this.writeLengthCodedNumber(b.length);\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeLengthCodedNumber(n) {\n    if (n < 0xfb) {\n      return this.writeInt8(n);\n    }\n\n    if (n < 0xffff) {\n      this.writeInt8(0xfc);\n      return this.writeInt16(n);\n    }\n\n    if (n < 0xffffff) {\n      this.writeInt8(0xfd);\n      return this.writeInt24(n);\n    }\n\n    if (n === null) {\n      return this.writeInt8(0xfb);\n    } // TODO: check that n is out of int precision\n\n\n    this.writeInt8(0xfe);\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n    this.buffer.writeUInt32LE(n >> 32, this.offset);\n    this.offset += 4;\n    return this.offset;\n  }\n\n  writeDate(d, timezone) {\n    this.buffer.writeUInt8(11, this.offset);\n\n    if (!timezone || timezone === 'local') {\n      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n    } else {\n      if (timezone !== 'Z') {\n        const offset = (timezone[0] === '-' ? -1 : 1) * (parseInt(timezone.substring(1, 3), 10) * 60 + parseInt(timezone.substring(4), 10));\n\n        if (offset !== 0) {\n          d = new Date(d.getTime() + 60000 * offset);\n        }\n      }\n\n      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n    }\n\n    this.offset += 12;\n  }\n\n  writeHeader(sequenceId) {\n    const offset = this.offset;\n    this.offset = 0;\n    this.writeInt24(this.buffer.length - 4);\n    this.writeInt8(sequenceId);\n    this.offset = offset;\n  }\n\n  clone() {\n    return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n  }\n\n  type() {\n    if (this.isEOF()) {\n      return 'EOF';\n    }\n\n    if (this.isError()) {\n      return 'Error';\n    }\n\n    if (this.buffer[this.offset] === 0) {\n      return 'maybeOK'; // could be other packet types as well\n    }\n\n    return '';\n  }\n\n  static lengthCodedNumberLength(n) {\n    if (n < 0xfb) {\n      return 1;\n    }\n\n    if (n < 0xffff) {\n      return 3;\n    }\n\n    if (n < 0xffffff) {\n      return 5;\n    }\n\n    return 9;\n  }\n\n  static lengthCodedStringLength(str, encoding) {\n    const buf = StringParser.encode(str, encoding);\n    const slen = buf.length;\n    return Packet.lengthCodedNumberLength(slen) + slen;\n  }\n\n  static MockBuffer() {\n    const noop = function () {};\n\n    const res = Buffer.alloc(0);\n\n    for (const op in NativeBuffer.prototype) {\n      if (typeof res[op] === 'function') {\n        res[op] = noop;\n      }\n    }\n\n    return res;\n  }\n\n}\n\nmodule.exports = Packet;","map":null,"metadata":{},"sourceType":"script"}