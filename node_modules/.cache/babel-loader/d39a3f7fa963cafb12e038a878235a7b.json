{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/davo/workspace/react-electron/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst QueryTypes = require('../../query-types');\n\nconst Op = require('../../operators');\n\nconst _require = require('../abstract/query-interface'),\n      QueryInterface = _require.QueryInterface;\n/**\n * The interface that Sequelize uses to talk with MSSQL database\n */\n\n\nclass MSSqlQueryInterface extends QueryInterface {\n  /**\n  * A wrapper that fixes MSSQL's inability to cleanly remove columns from existing tables if they have a default constraint.\n  *\n  * @override\n  */\n  async removeColumn(tableName, attributeName, options) {\n    options = {\n      raw: true,\n      ...(options || {})\n    };\n    const findConstraintSql = this.queryGenerator.getDefaultConstraintQuery(tableName, attributeName);\n\n    const _ref = await this.sequelize.query(findConstraintSql, options),\n          _ref2 = _slicedToArray(_ref, 1),\n          results0 = _ref2[0];\n\n    if (results0.length) {\n      // No default constraint found -- we can cleanly remove the column\n      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, results0[0].name);\n      await this.sequelize.query(dropConstraintSql, options);\n    }\n\n    const findForeignKeySql = this.queryGenerator.getForeignKeyQuery(tableName, attributeName);\n\n    const _ref3 = await this.sequelize.query(findForeignKeySql, options),\n          _ref4 = _slicedToArray(_ref3, 1),\n          results = _ref4[0];\n\n    if (results.length) {\n      // No foreign key constraints found, so we can remove the column\n      const dropForeignKeySql = this.queryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);\n      await this.sequelize.query(dropForeignKeySql, options);\n    } //Check if the current column is a primaryKey\n\n\n    const primaryKeyConstraintSql = this.queryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);\n\n    const _ref5 = await this.sequelize.query(primaryKeyConstraintSql, options),\n          _ref6 = _slicedToArray(_ref5, 1),\n          result = _ref6[0];\n\n    if (result.length) {\n      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, result[0].constraintName);\n      await this.sequelize.query(dropConstraintSql, options);\n    }\n\n    const removeSql = this.queryGenerator.removeColumnQuery(tableName, attributeName);\n    return this.sequelize.query(removeSql, options);\n  }\n  /**\n   * @override\n   */\n\n\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    const model = options.model;\n    const wheres = [];\n    options = { ...options\n    };\n\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    } // Lets combine unique keys and indexes into one\n\n\n    let indexes = Object.values(model.uniqueKeys).map(item => item.fields);\n    indexes = indexes.concat(Object.values(model._indexes).filter(item => item.unique).map(item => item.fields));\n    const attributes = Object.keys(insertValues);\n\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n\n        wheres.push(where);\n      }\n    }\n\n    where = {\n      [Op.or]: wheres\n    };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n}\n\nexports.MSSqlQueryInterface = MSSqlQueryInterface;","map":null,"metadata":{},"sourceType":"script"}