{"ast":null,"code":"'use strict';\n\nconst Net = require('net');\n\nconst Tls = require('tls');\n\nconst Timers = require('timers');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst Readable = require('stream').Readable;\n\nconst Queue = require('denque');\n\nconst SqlString = require('sqlstring');\n\nconst LRU = require('lru-cache');\n\nconst PacketParser = require('./packet_parser.js');\n\nconst Packets = require('./packets/index.js');\n\nconst Commands = require('./commands/index.js');\n\nconst ConnectionConfig = require('./connection_config.js');\n\nconst CharsetToEncoding = require('./constants/charset_encodings.js');\n\nlet _connectionId = 0;\nlet convertNamedPlaceholders = null;\n\nclass Connection extends EventEmitter {\n  constructor(opts) {\n    super();\n    this.config = opts.config; // TODO: fill defaults\n    // if no params, connect to /var/lib/mysql/mysql.sock ( /tmp/mysql.sock on OSX )\n    // if host is given, connect to host:3306\n    // TODO: use `/usr/local/mysql/bin/mysql_config --socket` output? as default socketPath\n    // if there is no host/port and no socketPath parameters?\n\n    if (!opts.config.stream) {\n      if (opts.config.socketPath) {\n        this.stream = Net.connect(opts.config.socketPath);\n      } else {\n        this.stream = Net.connect(opts.config.port, opts.config.host); // Enable keep-alive on the socket.  It's disabled by default, but the\n        // user can enable it and supply an initial delay.\n\n        this.stream.setKeepAlive(true, this.config.keepAliveInitialDelay);\n      } // if stream is a function, treat it as \"stream agent / factory\"\n\n    } else if (typeof opts.config.stream === 'function') {\n      this.stream = opts.config.stream(opts);\n    } else {\n      this.stream = opts.config.stream;\n    }\n\n    this._internalId = _connectionId++;\n    this._commands = new Queue();\n    this._command = null;\n    this._paused = false;\n    this._paused_packets = new Queue();\n    this._statements = new LRU({\n      max: this.config.maxPreparedStatements,\n      dispose: function (key, statement) {\n        statement.close();\n      }\n    });\n    this.serverCapabilityFlags = 0;\n    this.authorized = false;\n    this.sequenceId = 0;\n    this.compressedSequenceId = 0;\n    this.threadId = null;\n    this._handshakePacket = null;\n    this._fatalError = null;\n    this._protocolError = null;\n    this._outOfOrderPackets = [];\n    this.clientEncoding = CharsetToEncoding[this.config.charsetNumber];\n    this.stream.on('error', this._handleNetworkError.bind(this)); // see https://gist.github.com/khoomeister/4985691#use-that-instead-of-bind\n\n    this.packetParser = new PacketParser(p => {\n      this.handlePacket(p);\n    });\n    this.stream.on('data', data => {\n      if (this.connectTimeout) {\n        Timers.clearTimeout(this.connectTimeout);\n        this.connectTimeout = null;\n      }\n\n      this.packetParser.execute(data);\n    });\n    this.stream.on('close', () => {\n      // we need to set this flag everywhere where we want connection to close\n      if (this._closing) {\n        return;\n      }\n\n      if (!this._protocolError) {\n        // no particular error message before disconnect\n        this._protocolError = new Error('Connection lost: The server closed the connection.');\n        this._protocolError.fatal = true;\n        this._protocolError.code = 'PROTOCOL_CONNECTION_LOST';\n      }\n\n      this._notifyError(this._protocolError);\n    });\n    let handshakeCommand;\n\n    if (!this.config.isServer) {\n      handshakeCommand = new Commands.ClientHandshake(this.config.clientFlags);\n      handshakeCommand.on('end', () => {\n        // this happens when handshake finishes early and first packet is error\n        // and not server hello ( for example, 'Too many connactions' error)\n        if (!handshakeCommand.handshake) {\n          return;\n        }\n\n        this._handshakePacket = handshakeCommand.handshake;\n        this.threadId = handshakeCommand.handshake.connectionId;\n        this.emit('connect', handshakeCommand.handshake);\n      });\n      handshakeCommand.on('error', err => {\n        this._closing = true;\n\n        this._notifyError(err);\n      });\n      this.addCommand(handshakeCommand);\n    } // in case there was no initiall handshake but we need to read sting, assume it utf-8\n    // most common example: \"Too many connections\" error ( packet is sent immediately on connection attempt, we don't know server encoding yet)\n    // will be overwrittedn with actial encoding value as soon as server handshake packet is received\n\n\n    this.serverEncoding = 'utf8';\n\n    if (this.config.connectTimeout) {\n      const timeoutHandler = this._handleTimeoutError.bind(this);\n\n      this.connectTimeout = Timers.setTimeout(timeoutHandler, this.config.connectTimeout);\n    }\n  }\n\n  promise(promiseImpl) {\n    const PromiseConnection = require('../promise').PromiseConnection;\n\n    return new PromiseConnection(this, promiseImpl);\n  }\n\n  _addCommandClosedState(cmd) {\n    const err = new Error(\"Can't add new command when connection is in closed state\");\n    err.fatal = true;\n\n    if (cmd.onResult) {\n      cmd.onResult(err);\n    } else {\n      this.emit('error', err);\n    }\n  }\n\n  _handleFatalError(err) {\n    err.fatal = true; // stop receiving packets\n\n    this.stream.removeAllListeners('data');\n    this.addCommand = this._addCommandClosedState;\n\n    this.write = () => {\n      this.emit('error', new Error(\"Can't write in closed state\"));\n    };\n\n    this._notifyError(err);\n\n    this._fatalError = err;\n  }\n\n  _handleNetworkError(err) {\n    if (this.connectTimeout) {\n      Timers.clearTimeout(this.connectTimeout);\n      this.connectTimeout = null;\n    } // Do not throw an error when a connection ends with a RST,ACK packet\n\n\n    if (err.errno === 'ECONNRESET' && this._closing) {\n      return;\n    }\n\n    this._handleFatalError(err);\n  }\n\n  _handleTimeoutError() {\n    if (this.connectTimeout) {\n      Timers.clearTimeout(this.connectTimeout);\n      this.connectTimeout = null;\n    }\n\n    this.stream.destroy && this.stream.destroy();\n    const err = new Error('connect ETIMEDOUT');\n    err.errorno = 'ETIMEDOUT';\n    err.code = 'ETIMEDOUT';\n    err.syscall = 'connect';\n\n    this._handleNetworkError(err);\n  } // notify all commands in the queue and bubble error as connection \"error\"\n  // called on stream error or unexpected termination\n\n\n  _notifyError(err) {\n    if (this.connectTimeout) {\n      Timers.clearTimeout(this.connectTimeout);\n      this.connectTimeout = null;\n    } // prevent from emitting 'PROTOCOL_CONNECTION_LOST' after EPIPE or ECONNRESET\n\n\n    if (this._fatalError) {\n      return;\n    }\n\n    let command; // if there is no active command, notify connection\n    // if there are commands and all of them have callbacks, pass error via callback\n\n    let bubbleErrorToConnection = !this._command;\n\n    if (this._command && this._command.onResult) {\n      this._command.onResult(err);\n\n      this._command = null; // connection handshake is special because we allow it to be implicit\n      // if error happened during handshake, but there are others commands in queue\n      // then bubble error to other commands and not to connection\n    } else if (!(this._command && this._command.constructor === Commands.ClientHandshake && this._commands.length > 0)) {\n      bubbleErrorToConnection = true;\n    }\n\n    while (command = this._commands.shift()) {\n      if (command.onResult) {\n        command.onResult(err);\n      } else {\n        bubbleErrorToConnection = true;\n      }\n    } // notify connection if some comands in the queue did not have callbacks\n    // or if this is pool connection ( so it can be removed from pool )\n\n\n    if (bubbleErrorToConnection || this._pool) {\n      this.emit('error', err);\n    }\n  }\n\n  write(buffer) {\n    const result = this.stream.write(buffer, err => {\n      if (err) {\n        this._handleNetworkError(err);\n      }\n    });\n\n    if (!result) {\n      this.stream.emit('pause');\n    }\n  } // http://dev.mysql.com/doc/internals/en/sequence-id.html\n  //\n  // The sequence-id is incremented with each packet and may wrap around.\n  // It starts at 0 and is reset to 0 when a new command\n  // begins in the Command Phase.\n  // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html\n\n\n  _resetSequenceId() {\n    this.sequenceId = 0;\n    this.compressedSequenceId = 0;\n  }\n\n  _bumpCompressedSequenceId(numPackets) {\n    this.compressedSequenceId += numPackets;\n    this.compressedSequenceId %= 256;\n  }\n\n  _bumpSequenceId(numPackets) {\n    this.sequenceId += numPackets;\n    this.sequenceId %= 256;\n  }\n\n  writePacket(packet) {\n    const MAX_PACKET_LENGTH = 16777215;\n    const length = packet.length();\n    let chunk, offset, header;\n\n    if (length < MAX_PACKET_LENGTH) {\n      packet.writeHeader(this.sequenceId);\n\n      if (this.config.debug) {\n        // eslint-disable-next-line no-console\n        console.log(\"\".concat(this._internalId, \" \").concat(this.connectionId, \" <== \").concat(this._command._commandName, \"#\").concat(this._command.stateName(), \"(\").concat([this.sequenceId, packet._name, packet.length()].join(','), \")\")); // eslint-disable-next-line no-console\n\n        console.log(\"\".concat(this._internalId, \" \").concat(this.connectionId, \" <== \").concat(packet.buffer.toString('hex')));\n      }\n\n      this._bumpSequenceId(1);\n\n      this.write(packet.buffer);\n    } else {\n      if (this.config.debug) {\n        // eslint-disable-next-line no-console\n        console.log(\"\".concat(this._internalId, \" \").concat(this.connectionId, \" <== Writing large packet, raw content not written:\")); // eslint-disable-next-line no-console\n\n        console.log(\"\".concat(this._internalId, \" \").concat(this.connectionId, \" <== \").concat(this._command._commandName, \"#\").concat(this._command.stateName(), \"(\").concat([this.sequenceId, packet._name, packet.length()].join(','), \")\"));\n      }\n\n      for (offset = 4; offset < 4 + length; offset += MAX_PACKET_LENGTH) {\n        chunk = packet.buffer.slice(offset, offset + MAX_PACKET_LENGTH);\n\n        if (chunk.length === MAX_PACKET_LENGTH) {\n          header = Buffer.from([0xff, 0xff, 0xff, this.sequenceId]);\n        } else {\n          header = Buffer.from([chunk.length & 0xff, chunk.length >> 8 & 0xff, chunk.length >> 16 & 0xff, this.sequenceId]);\n        }\n\n        this._bumpSequenceId(1);\n\n        this.write(header);\n        this.write(chunk);\n      }\n    }\n  } // 0.11+ environment\n\n\n  startTLS(onSecure) {\n    if (this.config.debug) {\n      // eslint-disable-next-line no-console\n      console.log('Upgrading connection to TLS');\n    }\n\n    const secureContext = Tls.createSecureContext({\n      ca: this.config.ssl.ca,\n      cert: this.config.ssl.cert,\n      ciphers: this.config.ssl.ciphers,\n      key: this.config.ssl.key,\n      passphrase: this.config.ssl.passphrase,\n      minVersion: this.config.ssl.minVersion\n    });\n    const rejectUnauthorized = this.config.ssl.rejectUnauthorized;\n    let secureEstablished = false;\n    const secureSocket = new Tls.TLSSocket(this.stream, {\n      rejectUnauthorized: rejectUnauthorized,\n      requestCert: true,\n      secureContext: secureContext,\n      isServer: false\n    }); // error handler for secure socket\n\n    secureSocket.on('_tlsError', err => {\n      if (secureEstablished) {\n        this._handleNetworkError(err);\n      } else {\n        onSecure(err);\n      }\n    });\n    secureSocket.on('secure', () => {\n      secureEstablished = true;\n      onSecure(rejectUnauthorized ? secureSocket.ssl.verifyError() : null);\n    });\n    secureSocket.on('data', data => {\n      this.packetParser.execute(data);\n    });\n\n    this.write = buffer => {\n      secureSocket.write(buffer);\n    }; // start TLS communications\n\n\n    secureSocket._start();\n  }\n\n  pipe() {\n    if (this.stream instanceof Net.Stream) {\n      this.stream.ondata = (data, start, end) => {\n        this.packetParser.execute(data, start, end);\n      };\n    } else {\n      this.stream.on('data', data => {\n        this.packetParser.execute(data.parent, data.offset, data.offset + data.length);\n      });\n    }\n  }\n\n  protocolError(message, code) {\n    const err = new Error(message);\n    err.fatal = true;\n    err.code = code || 'PROTOCOL_ERROR';\n    this.emit('error', err);\n  }\n\n  handlePacket(packet) {\n    if (this._paused) {\n      this._paused_packets.push(packet);\n\n      return;\n    }\n\n    if (packet) {\n      if (this.sequenceId !== packet.sequenceId) {\n        const err = new Error(\"Warning: got packets out of order. Expected \".concat(this.sequenceId, \" but received \").concat(packet.sequenceId));\n        err.expected = this.sequenceId;\n        err.received = packet.sequenceId;\n        this.emit('warn', err); // REVIEW\n        // eslint-disable-next-line no-console\n\n        console.error(err.message);\n      }\n\n      this._bumpSequenceId(packet.numPackets);\n    }\n\n    if (this.config.debug) {\n      if (packet) {\n        // eslint-disable-next-line no-console\n        console.log(\" raw: \".concat(packet.buffer.slice(packet.offset, packet.offset + packet.length()).toString('hex'))); // eslint-disable-next-line no-console\n\n        console.trace();\n        const commandName = this._command ? this._command._commandName : '(no command)';\n        const stateName = this._command ? this._command.stateName() : '(no command)'; // eslint-disable-next-line no-console\n\n        console.log(\"\".concat(this._internalId, \" \").concat(this.connectionId, \" ==> \").concat(commandName, \"#\").concat(stateName, \"(\").concat([packet.sequenceId, packet.type(), packet.length()].join(','), \")\"));\n      }\n    }\n\n    if (!this._command) {\n      this.protocolError('Unexpected packet while no commands in the queue', 'PROTOCOL_UNEXPECTED_PACKET');\n      this.close();\n      return;\n    }\n\n    const done = this._command.execute(packet, this);\n\n    if (done) {\n      this._command = this._commands.shift();\n\n      if (this._command) {\n        this.sequenceId = 0;\n        this.compressedSequenceId = 0;\n        this.handlePacket();\n      }\n    }\n  }\n\n  addCommand(cmd) {\n    // this.compressedSequenceId = 0;\n    // this.sequenceId = 0;\n    if (this.config.debug) {\n      const commandName = cmd.constructor.name; // eslint-disable-next-line no-console\n\n      console.log(\"Add command: \".concat(commandName));\n      cmd._commandName = commandName;\n    }\n\n    if (!this._command) {\n      this._command = cmd;\n      this.handlePacket();\n    } else {\n      this._commands.push(cmd);\n    }\n\n    return cmd;\n  }\n\n  format(sql, values) {\n    if (typeof this.config.queryFormat === 'function') {\n      return this.config.queryFormat.call(this, sql, values, this.config.timezone);\n    }\n\n    const opts = {\n      sql: sql,\n      values: values\n    };\n\n    this._resolveNamedPlaceholders(opts);\n\n    return SqlString.format(opts.sql, opts.values, this.config.stringifyObjects, this.config.timezone);\n  }\n\n  escape(value) {\n    return SqlString.escape(value, false, this.config.timezone);\n  }\n\n  escapeId(value) {\n    return SqlString.escapeId(value, false);\n  }\n\n  raw(sql) {\n    return SqlString.raw(sql);\n  }\n\n  _resolveNamedPlaceholders(options) {\n    let unnamed;\n\n    if (this.config.namedPlaceholders || options.namedPlaceholders) {\n      if (convertNamedPlaceholders === null) {\n        convertNamedPlaceholders = require('named-placeholders')();\n      }\n\n      unnamed = convertNamedPlaceholders(options.sql, options.values);\n      options.sql = unnamed[0];\n      options.values = unnamed[1];\n    }\n  }\n\n  query(sql, values, cb) {\n    let cmdQuery;\n\n    if (sql.constructor === Commands.Query) {\n      cmdQuery = sql;\n    } else {\n      cmdQuery = Connection.createQuery(sql, values, cb, this.config);\n    }\n\n    this._resolveNamedPlaceholders(cmdQuery);\n\n    const rawSql = this.format(cmdQuery.sql, cmdQuery.values !== undefined ? cmdQuery.values : []);\n    cmdQuery.sql = rawSql;\n    return this.addCommand(cmdQuery);\n  }\n\n  pause() {\n    this._paused = true;\n    this.stream.pause();\n  }\n\n  resume() {\n    let packet;\n    this._paused = false;\n\n    while (packet = this._paused_packets.shift()) {\n      this.handlePacket(packet); // don't resume if packet hander paused connection\n\n      if (this._paused) {\n        return;\n      }\n    }\n\n    this.stream.resume();\n  } // TODO: named placeholders support\n\n\n  prepare(options, cb) {\n    if (typeof options === 'string') {\n      options = {\n        sql: options\n      };\n    }\n\n    return this.addCommand(new Commands.Prepare(options, cb));\n  }\n\n  unprepare(sql) {\n    let options = {};\n\n    if (typeof sql === 'object') {\n      options = sql;\n    } else {\n      options.sql = sql;\n    }\n\n    const key = Connection.statementKey(options);\n\n    const stmt = this._statements.get(key);\n\n    if (stmt) {\n      this._statements.del(key);\n\n      stmt.close();\n    }\n\n    return stmt;\n  }\n\n  execute(sql, values, cb) {\n    let options = {};\n\n    if (typeof sql === 'object') {\n      // execute(options, cb)\n      options = sql;\n\n      if (typeof values === 'function') {\n        cb = values;\n      } else {\n        options.values = options.values || values;\n      }\n    } else if (typeof values === 'function') {\n      // execute(sql, cb)\n      cb = values;\n      options.sql = sql;\n      options.values = undefined;\n    } else {\n      // execute(sql, values, cb)\n      options.sql = sql;\n      options.values = values;\n    }\n\n    this._resolveNamedPlaceholders(options); // check for values containing undefined\n\n\n    if (options.values) {\n      //If namedPlaceholder is not enabled and object is passed as bind parameters\n      if (!Array.isArray(options.values)) {\n        throw new TypeError('Bind parameters must be array if namedPlaceholders parameter is not enabled');\n      }\n\n      options.values.forEach(val => {\n        //If namedPlaceholder is not enabled and object is passed as bind parameters\n        if (!Array.isArray(options.values)) {\n          throw new TypeError('Bind parameters must be array if namedPlaceholders parameter is not enabled');\n        }\n\n        if (val === undefined) {\n          throw new TypeError('Bind parameters must not contain undefined. To pass SQL NULL specify JS null');\n        }\n\n        if (typeof val === 'function') {\n          throw new TypeError('Bind parameters must not contain function(s). To pass the body of a function as a string call .toString() first');\n        }\n      });\n    }\n\n    const executeCommand = new Commands.Execute(options, cb);\n    const prepareCommand = new Commands.Prepare(options, (err, stmt) => {\n      if (err) {\n        // skip execute command if prepare failed, we have main\n        // combined callback here\n        executeCommand.start = function () {\n          return null;\n        };\n\n        if (cb) {\n          cb(err);\n        } else {\n          executeCommand.emit('error', err);\n        }\n\n        executeCommand.emit('end');\n        return;\n      }\n\n      executeCommand.statement = stmt;\n    });\n    this.addCommand(prepareCommand);\n    this.addCommand(executeCommand);\n    return executeCommand;\n  }\n\n  changeUser(options, callback) {\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    const charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : this.config.charsetNumber;\n    return this.addCommand(new Commands.ChangeUser({\n      user: options.user || this.config.user,\n      password: options.password || this.config.password,\n      passwordSha1: options.passwordSha1 || this.config.passwordSha1,\n      database: options.database || this.config.database,\n      timeout: options.timeout,\n      charsetNumber: charsetNumber,\n      currentConfig: this.config\n    }, err => {\n      if (err) {\n        err.fatal = true;\n      }\n\n      if (callback) {\n        callback(err);\n      }\n    }));\n  } // transaction helpers\n\n\n  beginTransaction(cb) {\n    return this.query('START TRANSACTION', cb);\n  }\n\n  commit(cb) {\n    return this.query('COMMIT', cb);\n  }\n\n  rollback(cb) {\n    return this.query('ROLLBACK', cb);\n  }\n\n  ping(cb) {\n    return this.addCommand(new Commands.Ping(cb));\n  }\n\n  _registerSlave(opts, cb) {\n    return this.addCommand(new Commands.RegisterSlave(opts, cb));\n  }\n\n  _binlogDump(opts, cb) {\n    return this.addCommand(new Commands.BinlogDump(opts, cb));\n  } // currently just alias to close\n\n\n  destroy() {\n    this.close();\n  }\n\n  close() {\n    if (this.connectTimeout) {\n      Timers.clearTimeout(this.connectTimeout);\n      this.connectTimeout = null;\n    }\n\n    this._closing = true;\n    this.stream.end();\n    this.addCommand = this._addCommandClosedState;\n  }\n\n  createBinlogStream(opts) {\n    // TODO: create proper stream class\n    // TODO: use through2\n    let test = 1;\n    const stream = new Readable({\n      objectMode: true\n    });\n\n    stream._read = function () {\n      return {\n        data: test++\n      };\n    };\n\n    this._registerSlave(opts, () => {\n      const dumpCmd = this._binlogDump(opts);\n\n      dumpCmd.on('event', ev => {\n        stream.push(ev);\n      });\n      dumpCmd.on('eof', () => {\n        stream.push(null); // if non-blocking, then close stream to prevent errors\n\n        if (opts.flags && opts.flags & 0x01) {\n          this.close();\n        }\n      }); // TODO: pipe errors as well\n    });\n\n    return stream;\n  }\n\n  connect(cb) {\n    if (!cb) {\n      return;\n    }\n\n    if (this._fatalError || this._protocolError) {\n      return cb(this._fatalError || this._protocolError);\n    }\n\n    if (this._handshakePacket) {\n      return cb(null, this);\n    }\n\n    let connectCalled = 0;\n\n    function callbackOnce(isErrorHandler) {\n      return function (param) {\n        if (!connectCalled) {\n          if (isErrorHandler) {\n            cb(param);\n          } else {\n            cb(null, param);\n          }\n        }\n\n        connectCalled = 1;\n      };\n    }\n\n    this.once('error', callbackOnce(true));\n    this.once('connect', callbackOnce(false));\n  } // ===================================\n  // outgoing server connection methods\n  // ===================================\n\n\n  writeColumns(columns) {\n    this.writePacket(Packets.ResultSetHeader.toPacket(columns.length));\n    columns.forEach(column => {\n      this.writePacket(Packets.ColumnDefinition.toPacket(column, this.serverConfig.encoding));\n    });\n    this.writeEof();\n  } // row is array of columns, not hash\n\n\n  writeTextRow(column) {\n    this.writePacket(Packets.TextRow.toPacket(column, this.serverConfig.encoding));\n  }\n\n  writeTextResult(rows, columns) {\n    this.writeColumns(columns);\n    rows.forEach(row => {\n      const arrayRow = new Array(columns.length);\n      columns.forEach(column => {\n        arrayRow.push(row[column.name]);\n      });\n      this.writeTextRow(arrayRow);\n    });\n    this.writeEof();\n  }\n\n  writeEof(warnings, statusFlags) {\n    this.writePacket(Packets.EOF.toPacket(warnings, statusFlags));\n  }\n\n  writeOk(args) {\n    if (!args) {\n      args = {\n        affectedRows: 0\n      };\n    }\n\n    this.writePacket(Packets.OK.toPacket(args, this.serverConfig.encoding));\n  }\n\n  writeError(args) {\n    // if we want to send error before initial hello was sent, use default encoding\n    const encoding = this.serverConfig ? this.serverConfig.encoding : 'cesu8';\n    this.writePacket(Packets.Error.toPacket(args, encoding));\n  }\n\n  serverHandshake(args) {\n    this.serverConfig = args;\n    this.serverConfig.encoding = CharsetToEncoding[this.serverConfig.characterSet];\n    return this.addCommand(new Commands.ServerHandshake(args));\n  } // ===============================================================\n\n\n  end(callback) {\n    if (this.config.isServer) {\n      this._closing = true;\n      const quitCmd = new EventEmitter();\n      setImmediate(() => {\n        this.stream.end();\n        quitCmd.emit('end');\n      });\n      return quitCmd;\n    } // trigger error if more commands enqueued after end command\n\n\n    const quitCmd = this.addCommand(new Commands.Quit(callback));\n    this.addCommand = this._addCommandClosedState;\n    return quitCmd;\n  }\n\n  static createQuery(sql, values, cb, config) {\n    let options = {\n      rowsAsArray: config.rowsAsArray\n    };\n\n    if (typeof sql === 'object') {\n      // query(options, cb)\n      options = sql;\n\n      if (typeof values === 'function') {\n        cb = values;\n      } else if (values !== undefined) {\n        options.values = values;\n      }\n    } else if (typeof values === 'function') {\n      // query(sql, cb)\n      cb = values;\n      options.sql = sql;\n      options.values = undefined;\n    } else {\n      // query(sql, values, cb)\n      options.sql = sql;\n      options.values = values;\n    }\n\n    return new Commands.Query(options, cb);\n  }\n\n  static statementKey(options) {\n    return \"\".concat(typeof options.nestTables, \"/\").concat(options.nestTables, \"/\").concat(options.rowsAsArray).concat(options.sql);\n  }\n\n}\n\nif (Tls.TLSSocket) {// not supported\n} else {\n  Connection.prototype.startTLS = function _startTLS(onSecure) {\n    if (this.config.debug) {\n      // eslint-disable-next-line no-console\n      console.log('Upgrading connection to TLS');\n    }\n\n    const crypto = require('crypto');\n\n    const config = this.config;\n    const stream = this.stream;\n    const rejectUnauthorized = this.config.ssl.rejectUnauthorized;\n    const credentials = crypto.createCredentials({\n      key: config.ssl.key,\n      cert: config.ssl.cert,\n      passphrase: config.ssl.passphrase,\n      ca: config.ssl.ca,\n      ciphers: config.ssl.ciphers\n    });\n    const securePair = Tls.createSecurePair(credentials, false, true, rejectUnauthorized);\n\n    if (stream.ondata) {\n      stream.ondata = null;\n    }\n\n    stream.removeAllListeners('data');\n    stream.pipe(securePair.encrypted);\n    securePair.encrypted.pipe(stream);\n    securePair.cleartext.on('data', data => {\n      this.packetParser.execute(data);\n    });\n\n    this.write = function (buffer) {\n      securePair.cleartext.write(buffer);\n    };\n\n    securePair.on('secure', () => {\n      onSecure(rejectUnauthorized ? securePair.ssl.verifyError() : null);\n    });\n  };\n}\n\nmodule.exports = Connection;","map":null,"metadata":{},"sourceType":"script"}