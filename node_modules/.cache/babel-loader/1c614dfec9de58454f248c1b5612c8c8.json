{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst util = require('util');\n\nconst Op = require('../../operators');\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = ['CONSTRAINT_NAME as constraint_name', 'CONSTRAINT_NAME as constraintName', 'CONSTRAINT_SCHEMA as constraintSchema', 'CONSTRAINT_SCHEMA as constraintCatalog', 'TABLE_NAME as tableName', 'TABLE_SCHEMA as tableSchema', 'TABLE_SCHEMA as tableCatalog', 'COLUMN_NAME as columnName', 'REFERENCED_TABLE_SCHEMA as referencedTableSchema', 'REFERENCED_TABLE_SCHEMA as referencedTableCatalog', 'REFERENCED_TABLE_NAME as referencedTableName', 'REFERENCED_COLUMN_NAME as referencedColumnName'].join(',');\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = { ...this.OperatorMap,\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    };\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      charset: null,\n      collate: null,\n      ...options\n    };\n    return Utils.joinSQLFragments(['CREATE DATABASE IF NOT EXISTS', this.quoteIdentifier(databaseName), options.charset && \"DEFAULT CHARACTER SET \".concat(this.escape(options.charset)), options.collate && \"DEFAULT COLLATE \".concat(this.escape(options.collate)), ';']);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return \"DROP DATABASE IF EXISTS \".concat(this.quoteIdentifier(databaseName), \";\");\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = {\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null,\n      ...options\n    };\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1].replace('PRIMARY KEY', '')));\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType.replace('PRIMARY KEY', '')));\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1]));\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType));\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = \"uniq_\".concat(tableName, \"_\").concat(columns.fields.join('_'));\n          }\n\n          attributesClause += \", UNIQUE \".concat(this.quoteIdentifier(indexName), \" (\").concat(columns.fields.map(field => this.quoteIdentifier(field)).join(', '), \")\");\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += \", PRIMARY KEY (\".concat(pkString, \")\");\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += \", FOREIGN KEY (\".concat(this.quoteIdentifier(fkey), \") \").concat(foreignKeys[fkey]);\n      }\n    }\n\n    return Utils.joinSQLFragments(['CREATE TABLE IF NOT EXISTS', table, \"(\".concat(attributesClause, \")\"), \"ENGINE=\".concat(options.engine), options.comment && typeof options.comment === 'string' && \"COMMENT \".concat(this.escape(options.comment)), options.charset && \"DEFAULT CHARSET=\".concat(options.charset), options.collate && \"COLLATE \".concat(options.collate), options.initialAutoIncrement && \"AUTO_INCREMENT=\".concat(options.initialAutoIncrement), options.rowFormat && \"ROW_FORMAT=\".concat(options.rowFormat), ';']);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return \"SHOW FULL COLUMNS FROM \".concat(table, \";\");\n  }\n\n  showTablesQuery(database) {\n    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n\n    if (database) {\n      query += \" AND TABLE_SCHEMA = \".concat(this.escape(database));\n    } else {\n      query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')';\n    }\n\n    return \"\".concat(query, \";\");\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(table), 'ADD', this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key\n    }), ';']);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), 'DROP', this.quoteIdentifier(attributeName), ';']);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(\"FOREIGN KEY (\".concat(attrName, \") \").concat(definition));\n      } else {\n        attrString.push(\"`\".concat(attributeName, \"` `\").concat(attributeName, \"` \").concat(definition));\n      }\n    }\n\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), attrString.length && \"CHANGE \".concat(attrString.join(', ')), constraintString.length && \"ADD \".concat(constraintString.join(', ')), ';']);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(\"`\".concat(attrBefore, \"` `\").concat(attrName, \"` \").concat(definition));\n    }\n\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), 'CHANGE', attrString.join(', '), ';']);\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => \"\".concat(this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path)), \" = '\").concat(condition.value, \"'\"));\n        return conditions.join(' AND ');\n      }\n\n      if (smth.path) {\n        let str; // Allow specifying conditions using the sqlite json functions\n\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    } // null is stored as a string in mysql\n\n\n    if (value === null) {\n      return 'null';\n    }\n\n    return value;\n  }\n\n  truncateTableQuery(tableName) {\n    return \"TRUNCATE \".concat(this.quoteTable(tableName));\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = \"DELETE FROM \".concat(this.quoteTable(tableName));\n\n    if (options.limit) {\n      limit = \" LIMIT \".concat(this.escape(options.limit));\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += \" WHERE \".concat(where);\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return Utils.joinSQLFragments([\"SHOW INDEX FROM \".concat(this.quoteTable(tableName)), options && options.database && \"FROM `\".concat(options.database, \"`\")]);\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments(['SELECT CONSTRAINT_CATALOG AS constraintCatalog,', 'CONSTRAINT_NAME AS constraintName,', 'CONSTRAINT_SCHEMA AS constraintSchema,', 'CONSTRAINT_TYPE AS constraintType,', 'TABLE_NAME AS tableName,', 'TABLE_SCHEMA AS tableSchema', 'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS', \"WHERE table_name='\".concat(tableName, \"'\"), constraintName && \"AND constraint_name = '\".concat(constraintName, \"'\"), schemaName && \"AND TABLE_SCHEMA = '\".concat(schemaName, \"'\"), ';']);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(\"\".concat(tableName, \"_\").concat(indexNameOrAttributes.join('_')));\n    }\n\n    return Utils.joinSQLFragments(['DROP INDEX', this.quoteIdentifier(indexName), 'ON', this.quoteTable(tableName)]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({\n      escape: this.escape.bind(this)\n    });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    } // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n\n\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += \" DEFAULT \".concat(this.escape(attribute.defaultValue));\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += \" COMMENT \".concat(this.escape(attribute.comment));\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n\n    if (attribute.after) {\n      template += \" AFTER \".concat(this.quoteIdentifier(attribute.after));\n    }\n\n    if (attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(\"\".concat(options.tableName, \"_\").concat(attrName, \"_foreign_idx\"));\n        template += \", ADD CONSTRAINT \".concat(fkName, \" FOREIGN KEY (\").concat(attrName, \")\");\n      }\n\n      template += \" REFERENCES \".concat(this.quoteTable(attribute.references.model));\n\n      if (attribute.references.key) {\n        template += \" (\".concat(this.quoteIdentifier(attribute.references.key), \")\");\n      } else {\n        template += \" (\".concat(this.quoteIdentifier('id'), \")\");\n      }\n\n      if (attribute.onDelete) {\n        template += \" ON DELETE \".concat(attribute.onDelete.toUpperCase());\n      }\n\n      if (attribute.onUpdate) {\n        template += \" ON UPDATE \".concat(attribute.onUpdate.toUpperCase());\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    } // Check invalid json statement\n\n\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(\"Invalid json statement: \".concat(stmt));\n    } // return true if the statement has valid json function\n\n\n    return hasJsonFunction;\n  }\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments(['SELECT', FOREIGN_KEY_FIELDS, \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '\".concat(tableName, \"'\"), \"AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='\".concat(schemaName, \"'\"), 'AND REFERENCED_TABLE_NAME IS NOT NULL', ';']);\n  }\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments(['SELECT', FOREIGN_KEY_FIELDS, 'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE', 'WHERE (', [\"REFERENCED_TABLE_NAME = \".concat(quotedTableName), table.schema && \"AND REFERENCED_TABLE_SCHEMA = \".concat(quotedSchemaName), \"AND REFERENCED_COLUMN_NAME = \".concat(quotedColumnName)], ') OR (', [\"TABLE_NAME = \".concat(quotedTableName), table.schema && \"AND TABLE_SCHEMA = \".concat(quotedSchemaName), \"AND COLUMN_NAME = \".concat(quotedColumnName), 'AND REFERENCED_TABLE_NAME IS NOT NULL'], ')']);\n  }\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), 'DROP FOREIGN KEY', this.quoteIdentifier(foreignKey), ';']);\n  }\n\n} // private methods\n\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;","map":null,"metadata":{},"sourceType":"script"}