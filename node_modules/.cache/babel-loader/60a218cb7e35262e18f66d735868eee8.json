{"ast":null,"code":"'use strict';\n\nconst sequelizeErrors = require('../../errors');\n\nconst QueryTypes = require('../../query-types');\n\nconst _require = require('../abstract/query-interface'),\n      QueryInterface = _require.QueryInterface;\n\nconst _require2 = require('../../utils'),\n      cloneDeep = _require2.cloneDeep;\n\nconst _ = require('lodash');\n/**\n * The interface that Sequelize uses to talk with SQLite database\n */\n\n\nclass SQLiteQueryInterface extends QueryInterface {\n  /**\n   * A wrapper that fixes SQLite's inability to remove columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but without the obsolete column.\n   *\n   * @override\n   */\n  async removeColumn(tableName, attributeName, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    delete fields[attributeName];\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(\"\".concat(subQuery, \";\"), {\n      raw: true,\n      ...options\n    });\n  }\n  /**\n   * A wrapper that fixes SQLite's inability to change columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but with a modified version of the respective column.\n   *\n   * @override\n   */\n\n\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(\"\".concat(subQuery, \";\"), {\n      raw: true,\n      ...options\n    });\n  }\n  /**\n   * A wrapper that fixes SQLite's inability to rename columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but with a renamed version of the respective column.\n   *\n   * @override\n   */\n\n\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);\n    fields[attrNameAfter] = { ...fields[attrNameBefore]\n    };\n    delete fields[attrNameBefore];\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(\"\".concat(subQuery, \";\"), {\n      raw: true,\n      ...options\n    });\n  }\n  /**\n   * @override\n   */\n\n\n  async removeConstraint(tableName, constraintName, options) {\n    let createTableSql;\n    const constraints = await this.showConstraint(tableName, constraintName); // sqlite can't show only one constraint, so we find here the one to remove\n\n    const constraint = constraints.find(constaint => constaint.constraintName === constraintName);\n\n    if (!constraint) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: \"Constraint \".concat(constraintName, \" on table \").concat(tableName, \" does not exist\"),\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n\n    createTableSql = constraint.sql;\n    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);\n    let constraintSnippet = \", CONSTRAINT \".concat(constraint.constraintName, \" \").concat(constraint.constraintType, \" \").concat(constraint.constraintCondition);\n\n    if (constraint.constraintType === 'FOREIGN KEY') {\n      const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);\n      constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => this.queryGenerator.quoteIdentifier(columnName));\n      const referenceTableKeys = constraint.referenceTableKeys.join(', ');\n      constraintSnippet += \" REFERENCES \".concat(referenceTableName, \" (\").concat(referenceTableKeys, \")\");\n      constraintSnippet += \" ON UPDATE \".concat(constraint.updateAction);\n      constraintSnippet += \" ON DELETE \".concat(constraint.deleteAction);\n    }\n\n    createTableSql = createTableSql.replace(constraintSnippet, '');\n    createTableSql += ';';\n    const fields = await this.describeTable(tableName, options);\n\n    const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(\"\".concat(subQuery, \";\"), {\n      raw: true,\n      ...options\n    });\n  }\n  /**\n   * @override\n   */\n\n\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error('Fields must be specified through options.fields');\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    options = cloneDeep(options);\n    const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const constraints = await this.sequelize.query(describeCreateTableSql, { ...options,\n      type: QueryTypes.SELECT,\n      raw: true\n    });\n    let sql = constraints[0].sql;\n    const index = sql.length - 1; //Replace ending ')' with constraint snippet - Simulates String.replaceAt\n    //http://stackoverflow.com/questions/1431094\n\n    const createTableSql = \"\".concat(sql.substr(0, index), \", \").concat(constraintSnippet, \")\").concat(sql.substr(index + 1), \";\");\n    const fields = await this.describeTable(tableName, options);\n    sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(\"\".concat(subQuery, \";\"), {\n      raw: true,\n      ...options\n    });\n  }\n  /**\n   * @override\n   */\n\n\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const database = this.sequelize.config.database;\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, database);\n    const result = await this.sequelize.query(query, options);\n    return result.map(row => ({\n      tableName,\n      columnName: row.from,\n      referencedTableName: row.table,\n      referencedColumnName: row.to,\n      tableCatalog: database,\n      referencedTableCatalog: database\n    }));\n  }\n  /**\n   * @override\n   */\n\n\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    await this.sequelize.query('PRAGMA foreign_keys = OFF', options);\n    await this._dropAllTables(tableNames, skip, options);\n    await this.sequelize.query('PRAGMA foreign_keys = ON', options);\n  }\n  /**\n   * @override\n   */\n\n\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === 'string') {\n      schema = options;\n    } else if (typeof options === 'object' && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === 'object' && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = { ...options,\n      type: QueryTypes.DESCRIBE\n    };\n    const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);\n\n    try {\n      const data = await this.sequelize.query(sql, options);\n      /*\n       * If no data is returned from the query, then the table name may be wrong.\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n       */\n\n      if (_.isEmpty(data)) {\n        throw new Error(\"No description found for \\\"\".concat(tableName, \"\\\" table. Check the table name and schema; remember, they _are_ case sensitive.\"));\n      }\n\n      const indexes = await this.sequelize.query(sqlIndexes, options);\n\n      for (const prop in data) {\n        data[prop].unique = false;\n      }\n\n      for (const index of indexes) {\n        for (const field of index.fields) {\n          if (index.unique !== undefined) {\n            data[field.attribute].unique = index.unique;\n          }\n        }\n      }\n\n      const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);\n\n      for (const foreignKey of foreignKeys) {\n        data[foreignKey.columnName].references = {\n          model: foreignKey.referencedTableName,\n          key: foreignKey.referencedColumnName\n        };\n      }\n\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n        throw new Error(\"No description found for \\\"\".concat(tableName, \"\\\" table. Check the table name and schema; remember, they _are_ case sensitive.\"));\n      }\n\n      throw e;\n    }\n  }\n\n}\n\nexports.SQLiteQueryInterface = SQLiteQueryInterface;","map":null,"metadata":{},"sourceType":"script"}