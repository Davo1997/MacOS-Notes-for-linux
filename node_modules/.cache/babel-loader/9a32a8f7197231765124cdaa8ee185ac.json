{"ast":null,"code":"'use strict';\n\nconst CursorType = require('../constants/cursor');\n\nconst CommandCodes = require('../constants/commands');\n\nconst Types = require('../constants/types');\n\nconst Packet = require('../packets/packet');\n\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nfunction isJSON(value) {\n  return Array.isArray(value) || value.constructor === Object || typeof value.toJSON === 'function' && !Buffer.isBuffer(value);\n}\n/**\n * Converts a value to an object describing type, String/Buffer representation and length\n * @param {*} value\n */\n\n\nfunction toParameter(value, encoding, timezone) {\n  let type = Types.VAR_STRING;\n  let length;\n\n  let writer = function (value) {\n    // eslint-disable-next-line no-invalid-this\n    return Packet.prototype.writeLengthCodedString.call(this, value, encoding);\n  };\n\n  if (value !== null) {\n    switch (typeof value) {\n      case 'undefined':\n        throw new TypeError('Bind parameters must not contain undefined');\n\n      case 'number':\n        type = Types.DOUBLE;\n        length = 8;\n        writer = Packet.prototype.writeDouble;\n        break;\n\n      case 'boolean':\n        value = value | 0;\n        type = Types.TINY;\n        length = 1;\n        writer = Packet.prototype.writeInt8;\n        break;\n\n      case 'object':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          type = Types.DATETIME;\n          length = 12;\n\n          writer = function (value) {\n            // eslint-disable-next-line no-invalid-this\n            return Packet.prototype.writeDate.call(this, value, timezone);\n          };\n        } else if (isJSON(value)) {\n          value = JSON.stringify(value);\n          type = Types.JSON;\n        } else if (Buffer.isBuffer(value)) {\n          length = Packet.lengthCodedNumberLength(value.length) + value.length;\n          writer = Packet.prototype.writeLengthCodedBuffer;\n        }\n\n        break;\n\n      default:\n        value = value.toString();\n    }\n  } else {\n    value = '';\n    type = Types.NULL;\n  }\n\n  if (!length) {\n    length = Packet.lengthCodedStringLength(value, encoding);\n  }\n\n  return {\n    value,\n    type,\n    length,\n    writer\n  };\n}\n\nclass Execute {\n  constructor(id, parameters, charsetNumber, timezone) {\n    this.id = id;\n    this.parameters = parameters;\n    this.encoding = CharsetToEncoding[charsetNumber];\n    this.timezone = timezone;\n  }\n\n  toPacket() {\n    // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)\n    // and copy + reallocate if not enough\n    // 0 + 4 - length, seqId\n    // 4 + 1 - COM_EXECUTE\n    // 5 + 4 - stmtId\n    // 9 + 1 - flags\n    // 10 + 4 - iteration-count (always 1)\n    let length = 14;\n    let parameters;\n\n    if (this.parameters && this.parameters.length > 0) {\n      length += Math.floor((this.parameters.length + 7) / 8);\n      length += 1; // new-params-bound-flag\n\n      length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set\n\n      parameters = this.parameters.map(value => toParameter(value, this.encoding, this.timezone));\n      length += parameters.reduce((accumulator, parameter) => accumulator + parameter.length, 0);\n    }\n\n    const buffer = Buffer.allocUnsafe(length);\n    const packet = new Packet(0, buffer, 0, length);\n    packet.offset = 4;\n    packet.writeInt8(CommandCodes.STMT_EXECUTE);\n    packet.writeInt32(this.id);\n    packet.writeInt8(CursorType.NO_CURSOR); // flags\n\n    packet.writeInt32(1); // iteration-count, always 1\n\n    if (parameters) {\n      let bitmap = 0;\n      let bitValue = 1;\n      parameters.forEach(parameter => {\n        if (parameter.type === Types.NULL) {\n          bitmap += bitValue;\n        }\n\n        bitValue *= 2;\n\n        if (bitValue === 256) {\n          packet.writeInt8(bitmap);\n          bitmap = 0;\n          bitValue = 1;\n        }\n      });\n\n      if (bitValue !== 1) {\n        packet.writeInt8(bitmap);\n      } // TODO: explain meaning of the flag\n      // afaik, if set n*2 bytes with type of parameter are sent before parameters\n      // if not, previous execution types are used (TODO prooflink)\n\n\n      packet.writeInt8(1); // new-params-bound-flag\n      // Write parameter types\n\n      parameters.forEach(parameter => {\n        packet.writeInt8(parameter.type); // field type\n\n        packet.writeInt8(0); // parameter flag\n      }); // Write parameter values\n\n      parameters.forEach(parameter => {\n        if (parameter.type !== Types.NULL) {\n          parameter.writer.call(packet, parameter.value);\n        }\n      });\n    }\n\n    return packet;\n  }\n\n}\n\nmodule.exports = Execute;","map":null,"metadata":{},"sourceType":"script"}