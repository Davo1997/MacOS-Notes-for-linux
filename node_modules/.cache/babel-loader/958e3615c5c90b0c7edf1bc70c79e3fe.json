{"ast":null,"code":"'use strict';\n\nconst Command = require('./command.js');\n\nconst Packets = require('../packets/index.js');\n\nconst ClientConstants = require('../constants/client.js');\n\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nconst auth41 = require('../auth_41.js');\n\nfunction flagNames(flags) {\n  const res = [];\n\n  for (const c in ClientConstants) {\n    if (flags & ClientConstants[c]) {\n      res.push(c.replace(/_/g, ' ').toLowerCase());\n    }\n  }\n\n  return res;\n}\n\nclass ClientHandshake extends Command {\n  constructor(clientFlags) {\n    super();\n    this.handshake = null;\n    this.clientFlags = clientFlags;\n  }\n\n  start() {\n    return ClientHandshake.prototype.handshakeInit;\n  }\n\n  sendSSLRequest(connection) {\n    const sslRequest = new Packets.SSLRequest(this.clientFlags, connection.config.charsetNumber);\n    connection.writePacket(sslRequest.toPacket());\n  }\n\n  sendCredentials(connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('Sending handshake packet: flags:%d=(%s)', this.clientFlags, flagNames(this.clientFlags).join(', '));\n    }\n\n    this.user = connection.config.user;\n    this.password = connection.config.password;\n    this.passwordSha1 = connection.config.passwordSha1;\n    this.database = connection.config.database;\n    this.autPluginName = this.handshake.autPluginName;\n    const handshakeResponse = new Packets.HandshakeResponse({\n      flags: this.clientFlags,\n      user: this.user,\n      database: this.database,\n      password: this.password,\n      passwordSha1: this.passwordSha1,\n      charsetNumber: connection.config.charsetNumber,\n      authPluginData1: this.handshake.authPluginData1,\n      authPluginData2: this.handshake.authPluginData2,\n      compress: connection.config.compress,\n      connectAttributes: connection.config.connectAttributes\n    });\n    connection.writePacket(handshakeResponse.toPacket());\n  }\n\n  calculateNativePasswordAuthToken(authPluginData) {\n    // TODO: dont split into authPluginData1 and authPluginData2, instead join when 1 & 2 received\n    const authPluginData1 = authPluginData.slice(0, 8);\n    const authPluginData2 = authPluginData.slice(8, 20);\n    let authToken;\n\n    if (this.passwordSha1) {\n      authToken = auth41.calculateTokenFromPasswordSha(this.passwordSha1, authPluginData1, authPluginData2);\n    } else {\n      authToken = auth41.calculateToken(this.password, authPluginData1, authPluginData2);\n    }\n\n    return authToken;\n  }\n\n  handshakeInit(helloPacket, connection) {\n    this.on('error', e => {\n      connection._fatalError = e;\n      connection._protocolError = e;\n    });\n    this.handshake = Packets.Handshake.fromPacket(helloPacket);\n\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('Server hello packet: capability flags:%d=(%s)', this.handshake.capabilityFlags, flagNames(this.handshake.capabilityFlags).join(', '));\n    }\n\n    connection.serverCapabilityFlags = this.handshake.capabilityFlags;\n    connection.serverEncoding = CharsetToEncoding[this.handshake.characterSet];\n    connection.connectionId = this.handshake.connectionId;\n    const serverSSLSupport = this.handshake.capabilityFlags & ClientConstants.SSL; // use compression only if requested by client and supported by server\n\n    connection.config.compress = connection.config.compress && this.handshake.capabilityFlags & ClientConstants.COMPRESS;\n    this.clientFlags = this.clientFlags | connection.config.compress;\n\n    if (connection.config.ssl) {\n      // client requires SSL but server does not support it\n      if (!serverSSLSupport) {\n        const err = new Error('Server does not support secure connnection');\n        err.code = 'HANDSHAKE_NO_SSL_SUPPORT';\n        err.fatal = true;\n        this.emit('error', err);\n        return false;\n      } // send ssl upgrade request and immediately upgrade connection to secure\n\n\n      this.clientFlags |= ClientConstants.SSL;\n      this.sendSSLRequest(connection);\n      connection.startTLS(err => {\n        // after connection is secure\n        if (err) {\n          // SSL negotiation error are fatal\n          err.code = 'HANDSHAKE_SSL_ERROR';\n          err.fatal = true;\n          this.emit('error', err);\n          return;\n        } // rest of communication is encrypted\n\n\n        this.sendCredentials(connection);\n      });\n    } else {\n      this.sendCredentials(connection);\n    }\n\n    return ClientHandshake.prototype.handshakeResult;\n  }\n\n  handshakeResult(packet, connection) {\n    const marker = packet.peekByte();\n\n    if (marker === 0xfe || marker === 1) {\n      const authSwitch = require('./auth_switch');\n\n      try {\n        if (marker === 1) {\n          authSwitch.authSwitchRequestMoreData(packet, connection, this);\n        } else {\n          authSwitch.authSwitchRequest(packet, connection, this);\n        }\n\n        return ClientHandshake.prototype.handshakeResult;\n      } catch (err) {\n        if (this.onResult) {\n          this.onResult(err);\n        } else {\n          connection.emit('error', err);\n        }\n\n        return null;\n      }\n    }\n\n    if (marker !== 0) {\n      const err = new Error('Unexpected packet during handshake phase');\n\n      if (this.onResult) {\n        this.onResult(err);\n      } else {\n        connection.emit('error', err);\n      }\n\n      return null;\n    } // this should be called from ClientHandshake command only\n    // and skipped when called from ChangeUser command\n\n\n    if (!connection.authorized) {\n      connection.authorized = true;\n\n      if (connection.config.compress) {\n        const enableCompression = require('../compressed_protocol.js').enableCompression;\n\n        enableCompression(connection);\n      }\n    }\n\n    if (this.onResult) {\n      this.onResult(null);\n    }\n\n    return null;\n  }\n\n}\n\nmodule.exports = ClientHandshake;","map":null,"metadata":{},"sourceType":"script"}