{"ast":null,"code":"'use strict';\n\nconst BaseError = require('../../errors/base-error');\n\nconst ConnectionError = require('../../errors/connection-error');\n/**\n * Thrown when a connection to a database is closed while an operation is in progress\n */\n\n\nclass AsyncQueueError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeAsyncQueueError';\n  }\n\n}\n\nexports.AsyncQueueError = AsyncQueueError;\n\nclass AsyncQueue {\n  constructor() {\n    this.previous = Promise.resolve();\n    this.closed = false;\n\n    this.rejectCurrent = () => {};\n  }\n\n  close() {\n    this.closed = true;\n    this.rejectCurrent(new ConnectionError(new AsyncQueueError('the connection was closed before this query could finish executing')));\n  }\n\n  enqueue(asyncFunction) {\n    // This outer promise might seems superflous since down below we return asyncFunction().then(resolve, reject).\n    // However, this ensures that this.previous will never be a rejected promise so the queue will\n    // always keep going, while still communicating rejection from asyncFunction to the user.\n    return new Promise((resolve, reject) => {\n      this.previous = this.previous.then(() => {\n        this.rejectCurrent = reject;\n\n        if (this.closed) {\n          return reject(new ConnectionError(new AsyncQueueError('the connection was closed before this query could be executed')));\n        }\n\n        return asyncFunction().then(resolve, reject);\n      });\n    });\n  }\n\n}\n\nexports.default = AsyncQueue;","map":null,"metadata":{},"sourceType":"script"}