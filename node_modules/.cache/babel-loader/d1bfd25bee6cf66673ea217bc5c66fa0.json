{"ast":null,"code":"'use strict';\n\nconst PLUGIN_NAME = 'sha256_password';\n\nconst crypto = require('crypto');\n\nconst _require = require('../auth_41'),\n      xor = _require.xor;\n\nconst REQUEST_SERVER_KEY_PACKET = Buffer.from([1]);\nconst STATE_INITIAL = 0;\nconst STATE_WAIT_SERVER_KEY = 1;\nconst STATE_FINAL = -1;\n\nfunction encrypt(password, scramble, key) {\n  const stage1 = xor(Buffer.from(\"\".concat(password, \"\\0\"), 'utf8').toString('binary'), scramble.toString('binary'));\n  return crypto.publicEncrypt(key, stage1);\n}\n\nmodule.exports = (pluginOptions = {}) => ({\n  connection\n}) => {\n  let state = 0;\n  let scramble = null;\n  const password = connection.config.password;\n\n  const authWithKey = serverKey => {\n    const _password = encrypt(password, scramble, serverKey);\n\n    state = STATE_FINAL;\n    return _password;\n  };\n\n  return data => {\n    switch (state) {\n      case STATE_INITIAL:\n        scramble = data.slice(0, 20); // if client provides key we can save one extra roundrip on first connection\n\n        if (pluginOptions.serverPublicKey) {\n          return authWithKey(pluginOptions.serverPublicKey);\n        }\n\n        state = STATE_WAIT_SERVER_KEY;\n        return REQUEST_SERVER_KEY_PACKET;\n\n      case STATE_WAIT_SERVER_KEY:\n        if (pluginOptions.onServerPublicKey) {\n          pluginOptions.onServerPublicKey(data);\n        }\n\n        return authWithKey(data);\n\n      case STATE_FINAL:\n        throw new Error(\"Unexpected data in AuthMoreData packet received by \".concat(PLUGIN_NAME, \" plugin in STATE_FINAL state.\"));\n    }\n\n    throw new Error(\"Unexpected data in AuthMoreData packet received by \".concat(PLUGIN_NAME, \" plugin in state \").concat(state));\n  };\n};","map":null,"metadata":{},"sourceType":"script"}