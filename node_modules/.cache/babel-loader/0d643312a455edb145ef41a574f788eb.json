{"ast":null,"code":"'use strict';\n\nconst process = require('process');\n\nconst AuthSwitchRequest = require('./auth_switch_request');\n\nconst AuthSwitchRequestMoreData = require('./auth_switch_request_more_data');\n\nconst AuthSwitchResponse = require('./auth_switch_response');\n\nconst BinaryRow = require('./binary_row');\n\nconst BinlogDump = require('./binlog_dump');\n\nconst ChangeUser = require('./change_user');\n\nconst CloseStatement = require('./close_statement');\n\nconst ColumnDefinition = require('./column_definition');\n\nconst Execute = require('./execute');\n\nconst Handshake = require('./handshake');\n\nconst HandshakeResponse = require('./handshake_response');\n\nconst PrepareStatement = require('./prepare_statement');\n\nconst PreparedStatementHeader = require('./prepared_statement_header');\n\nconst Query = require('./query');\n\nconst RegisterSlave = require('./register_slave');\n\nconst ResultSetHeader = require('./resultset_header');\n\nconst SSLRequest = require('./ssl_request');\n\nconst TextRow = require('./text_row');\n\nconst ctorMap = {\n  AuthSwitchRequest,\n  AuthSwitchRequestMoreData,\n  AuthSwitchResponse,\n  BinaryRow,\n  BinlogDump,\n  ChangeUser,\n  CloseStatement,\n  ColumnDefinition,\n  Execute,\n  Handshake,\n  HandshakeResponse,\n  PrepareStatement,\n  PreparedStatementHeader,\n  Query,\n  RegisterSlave,\n  ResultSetHeader,\n  SSLRequest,\n  TextRow\n};\nObject.entries(ctorMap).forEach(([name, ctor]) => {\n  module.exports[name] = ctor; // monkey-patch it to include name if debug is on\n\n  if (process.env.NODE_DEBUG) {\n    if (ctor.prototype.toPacket) {\n      const old = ctor.prototype.toPacket;\n\n      ctor.prototype.toPacket = function () {\n        const p = old.call(this);\n        p._name = name;\n        return p;\n      };\n    }\n  }\n}); // simple packets:\n\nconst Packet = require('./packet');\n\nexports.Packet = Packet;\n\nclass OK {\n  static toPacket(args, encoding) {\n    args = args || {};\n    const affectedRows = args.affectedRows || 0;\n    const insertId = args.insertId || 0;\n    const serverStatus = args.serverStatus || 0;\n    const warningCount = args.warningCount || 0;\n    const message = args.message || '';\n    let length = 9 + Packet.lengthCodedNumberLength(affectedRows);\n    length += Packet.lengthCodedNumberLength(insertId);\n    const buffer = Buffer.allocUnsafe(length);\n    const packet = new Packet(0, buffer, 0, length);\n    packet.offset = 4;\n    packet.writeInt8(0);\n    packet.writeLengthCodedNumber(affectedRows);\n    packet.writeLengthCodedNumber(insertId);\n    packet.writeInt16(serverStatus);\n    packet.writeInt16(warningCount);\n    packet.writeString(message, encoding);\n    packet._name = 'OK';\n    return packet;\n  }\n\n}\n\nexports.OK = OK; // warnings, statusFlags\n\nclass EOF {\n  static toPacket(warnings, statusFlags) {\n    if (typeof warnings === 'undefined') {\n      warnings = 0;\n    }\n\n    if (typeof statusFlags === 'undefined') {\n      statusFlags = 0;\n    }\n\n    const packet = new Packet(0, Buffer.allocUnsafe(9), 0, 9);\n    packet.offset = 4;\n    packet.writeInt8(0xfe);\n    packet.writeInt16(warnings);\n    packet.writeInt16(statusFlags);\n    packet._name = 'EOF';\n    return packet;\n  }\n\n}\n\nexports.EOF = EOF;\n\nclass Error {\n  static toPacket(args, encoding) {\n    const length = 13 + Buffer.byteLength(args.message, 'utf8');\n    const packet = new Packet(0, Buffer.allocUnsafe(length), 0, length);\n    packet.offset = 4;\n    packet.writeInt8(0xff);\n    packet.writeInt16(args.code); // TODO: sql state parameter\n\n    packet.writeString('#_____', encoding);\n    packet.writeString(args.message, encoding);\n    packet._name = 'Error';\n    return packet;\n  }\n\n}\n\nexports.Error = Error;","map":null,"metadata":{},"sourceType":"script"}