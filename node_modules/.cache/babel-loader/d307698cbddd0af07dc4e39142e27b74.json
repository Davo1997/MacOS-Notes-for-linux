{"ast":null,"code":"'use strict'; // based on code from Brian White @mscdex mariasql library - https://github.com/mscdex/node-mariasql/blob/master/lib/Client.js#L272-L332\n// License: https://github.com/mscdex/node-mariasql/blob/master/LICENSE\n\nconst RE_PARAM = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g,\n      DQUOTE = 34,\n      SQUOTE = 39,\n      BSLASH = 92;\n\nfunction parse(query) {\n  let ppos = RE_PARAM.exec(query);\n  let curpos = 0;\n  let start = 0;\n  let end;\n  const parts = [];\n  let inQuote = false;\n  let escape = false;\n  let qchr;\n  const tokens = [];\n  let qcnt = 0;\n  let lastTokenEndPos = 0;\n  let i;\n\n  if (ppos) {\n    do {\n      for (i = curpos, end = ppos.index; i < end; ++i) {\n        let chr = query.charCodeAt(i);\n        if (chr === BSLASH) escape = !escape;else {\n          if (escape) {\n            escape = false;\n            continue;\n          }\n\n          if (inQuote && chr === qchr) {\n            if (query.charCodeAt(i + 1) === qchr) {\n              // quote escaped via \"\" or ''\n              ++i;\n              continue;\n            }\n\n            inQuote = false;\n          } else if (chr === DQUOTE || chr === SQUOTE) {\n            inQuote = true;\n            qchr = chr;\n          }\n        }\n      }\n\n      if (!inQuote) {\n        parts.push(query.substring(start, end));\n        tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);\n        start = end + ppos[0].length;\n        lastTokenEndPos = start;\n      }\n\n      curpos = end + ppos[0].length;\n    } while (ppos = RE_PARAM.exec(query));\n\n    if (tokens.length) {\n      if (curpos < query.length) {\n        parts.push(query.substring(lastTokenEndPos));\n      }\n\n      return [parts, tokens];\n    }\n  }\n\n  return [query];\n}\n\n;\n\nconst EMPTY_LRU_FN = (key, value) => {};\n\nfunction createCompiler(config) {\n  if (!config) config = {};\n\n  if (!config.placeholder) {\n    config.placeholder = '?';\n  }\n\n  let ncache = 100;\n  let cache;\n\n  if (typeof config.cache === 'number') {\n    ncache = config.cache;\n  }\n\n  if (typeof config.cache === 'object') {\n    cache = config.cache;\n  }\n\n  if (config.cache !== false && !cache) {\n    cache = require('lru-cache')({\n      max: ncache,\n      dispose: EMPTY_LRU_FN\n    });\n  }\n\n  function toArrayParams(tree, params) {\n    const arr = [];\n\n    if (tree.length == 1) {\n      return [tree[0], []];\n    }\n\n    if (typeof params == 'undefined') throw new Error('Named query contains placeholders, but parameters object is undefined');\n    const tokens = tree[1];\n\n    for (let i = 0; i < tokens.length; ++i) {\n      arr.push(params[tokens[i]]);\n    }\n\n    return [tree[0], arr];\n  }\n\n  function noTailingSemicolon(s) {\n    if (s.slice(-1) == ':') {\n      return s.slice(0, -1);\n    }\n\n    return s;\n  }\n\n  function join(tree) {\n    if (tree.length == 1) {\n      return tree;\n    }\n\n    let unnamed = noTailingSemicolon(tree[0][0]);\n\n    for (let i = 1; i < tree[0].length; ++i) {\n      if (tree[0][i - 1].slice(-1) == ':') {\n        unnamed += config.placeholder;\n      }\n\n      unnamed += config.placeholder;\n      unnamed += noTailingSemicolon(tree[0][i]);\n    }\n\n    const last = tree[0][tree[0].length - 1];\n\n    if (tree[0].length == tree[1].length) {\n      if (last.slice(-1) == ':') {\n        unnamed += config.placeholder;\n      }\n\n      unnamed += config.placeholder;\n    }\n\n    return [unnamed, tree[1]];\n  }\n\n  function compile(query, paramsObj) {\n    let tree;\n\n    if (cache && (tree = cache.get(query))) {\n      return toArrayParams(tree, paramsObj);\n    }\n\n    tree = join(parse(query));\n\n    if (cache) {\n      cache.set(query, tree);\n    }\n\n    return toArrayParams(tree, paramsObj);\n  }\n\n  compile.parse = parse;\n  return compile;\n} // named :one :two to postgres-style numbered $1 $2 $3\n\n\nfunction toNumbered(q, params) {\n  const tree = parse(q);\n  const paramsArr = [];\n\n  if (tree.length == 1) {\n    return [tree[0], paramsArr];\n  }\n\n  const pIndexes = {};\n  let pLastIndex = 0;\n  let qs = '';\n  let varIndex;\n  const varNames = [];\n\n  for (let i = 0; i < tree[0].length; ++i) {\n    varIndex = pIndexes[tree[1][i]];\n\n    if (!varIndex) {\n      varIndex = ++pLastIndex;\n      pIndexes[tree[1][i]] = varIndex;\n    }\n\n    if (tree[1][i]) {\n      varNames[varIndex - 1] = tree[1][i];\n      qs += tree[0][i] + '$' + varIndex;\n    } else {\n      qs += tree[0][i];\n    }\n  }\n\n  return [qs, varNames.map(n => params[n])];\n}\n\nmodule.exports = createCompiler;\nmodule.exports.toNumbered = toNumbered;","map":null,"metadata":{},"sourceType":"script"}