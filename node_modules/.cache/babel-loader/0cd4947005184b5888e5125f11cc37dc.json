{"ast":null,"code":"'use strict'; // https://mysqlserverteam.com/mysql-8-0-4-new-default-authentication-plugin-caching_sha2_password/\n\nconst PLUGIN_NAME = 'caching_sha2_password';\n\nconst crypto = require('crypto');\n\nconst _require = require('../auth_41'),\n      xor = _require.xor,\n      xorRotating = _require.xorRotating;\n\nconst REQUEST_SERVER_KEY_PACKET = Buffer.from([2]);\nconst FAST_AUTH_SUCCESS_PACKET = Buffer.from([3]);\nconst PERFORM_FULL_AUTHENTICATION_PACKET = Buffer.from([4]);\nconst STATE_INITIAL = 0;\nconst STATE_TOKEN_SENT = 1;\nconst STATE_WAIT_SERVER_KEY = 2;\nconst STATE_FINAL = -1;\n\nfunction sha256(msg) {\n  const hash = crypto.createHash('sha256');\n  hash.update(msg, 'binary');\n  return hash.digest('binary');\n}\n\nfunction calculateToken(password, scramble) {\n  if (!password) {\n    return Buffer.alloc(0);\n  }\n\n  const stage1 = sha256(Buffer.from(password, 'utf8').toString('binary'));\n  const stage2 = sha256(stage1);\n  const stage3 = sha256(stage2 + scramble.toString('binary'));\n  return xor(stage1, stage3);\n}\n\nfunction encrypt(password, scramble, key) {\n  const stage1 = xorRotating(Buffer.from(\"\".concat(password, \"\\0\"), 'utf8').toString('binary'), scramble.toString('binary'));\n  return crypto.publicEncrypt(key, stage1);\n}\n\nmodule.exports = (pluginOptions = {}) => ({\n  connection\n}) => {\n  let state = 0;\n  let scramble = null;\n  const password = connection.config.password;\n\n  const authWithKey = serverKey => {\n    const _password = encrypt(password, scramble, serverKey);\n\n    state = STATE_FINAL;\n    return _password;\n  };\n\n  return data => {\n    switch (state) {\n      case STATE_INITIAL:\n        scramble = data.slice(0, 20);\n        state = STATE_TOKEN_SENT;\n        return calculateToken(password, scramble);\n\n      case STATE_TOKEN_SENT:\n        if (FAST_AUTH_SUCCESS_PACKET.equals(data)) {\n          state = STATE_FINAL;\n          return null;\n        }\n\n        if (PERFORM_FULL_AUTHENTICATION_PACKET.equals(data)) {\n          const isSecureConnection = typeof pluginOptions.overrideIsSecure === 'undefined' ? connection.config.ssl || connection.config.socketPath : pluginOptions.overrideIsSecure;\n\n          if (isSecureConnection) {\n            state = STATE_FINAL;\n            return Buffer.from(\"\".concat(password, \"\\0\"), 'utf8');\n          } // if client provides key we can save one extra roundrip on first connection\n\n\n          if (pluginOptions.serverPublicKey) {\n            return authWithKey(pluginOptions.serverPublicKey);\n          }\n\n          state = STATE_WAIT_SERVER_KEY;\n          return REQUEST_SERVER_KEY_PACKET;\n        }\n\n        throw new Error(\"Invalid AuthMoreData packet received by \".concat(PLUGIN_NAME, \" plugin in STATE_TOKEN_SENT state.\"));\n\n      case STATE_WAIT_SERVER_KEY:\n        if (pluginOptions.onServerPublicKey) {\n          pluginOptions.onServerPublicKey(data);\n        }\n\n        return authWithKey(data);\n\n      case STATE_FINAL:\n        throw new Error(\"Unexpected data in AuthMoreData packet received by \".concat(PLUGIN_NAME, \" plugin in STATE_FINAL state.\"));\n    }\n\n    throw new Error(\"Unexpected data in AuthMoreData packet received by \".concat(PLUGIN_NAME, \" plugin in state \").concat(state));\n  };\n};","map":null,"metadata":{},"sourceType":"script"}