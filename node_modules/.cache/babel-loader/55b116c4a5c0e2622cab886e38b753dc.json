{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pool = void 0;\n\nconst Deferred_1 = require(\"./Deferred\");\n\nconst AggregateError_1 = require(\"./AggregateError\");\n\nclass Pool {\n  constructor(factory) {\n    this.log = false;\n\n    if (!factory.create) {\n      throw new Error('create function is required');\n    }\n\n    if (!factory.destroy) {\n      throw new Error('destroy function is required');\n    }\n\n    if (!factory.validate) {\n      throw new Error('validate function is required');\n    }\n\n    if (typeof factory.min !== 'number' || factory.min < 0 || factory.min !== Math.round(factory.min)) {\n      throw new Error('min must be an integer >= 0');\n    }\n\n    if (typeof factory.max !== 'number' || factory.max <= 0 || factory.max !== Math.round(factory.max)) {\n      throw new Error('max must be an integer > 0');\n    }\n\n    if (factory.min > factory.max) {\n      throw new Error('max is smaller than min');\n    }\n\n    if (factory.maxUses !== undefined && (typeof factory.maxUses !== 'number' || factory.maxUses < 0)) {\n      throw new Error('maxUses must be an integer >= 0');\n    }\n\n    this.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;\n    this.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;\n    this.reapIntervalMillis = factory.reapIntervalMillis || 1000;\n    this.maxUsesPerResource = factory.maxUses || Infinity;\n    this.log = factory.log || false;\n    this._factory = factory;\n    this._count = 0;\n    this._draining = false;\n    this._pendingAcquires = [];\n    this._inUseObjects = [];\n    this._availableObjects = [];\n    this._removeIdleScheduled = false;\n  }\n\n  get size() {\n    return this._count;\n  }\n\n  get name() {\n    return this._factory.name;\n  }\n\n  get available() {\n    return this._availableObjects.length;\n  }\n\n  get using() {\n    return this._inUseObjects.length;\n  }\n\n  get waiting() {\n    return this._pendingAcquires.length;\n  }\n\n  get maxSize() {\n    return this._factory.max;\n  }\n\n  get minSize() {\n    return this._factory.min;\n  }\n\n  _log(message, level) {\n    if (typeof this.log === 'function') {\n      this.log(message, level);\n    } else if (this.log) {\n      console.log(\"\".concat(level.toUpperCase(), \" pool \").concat(this.name || '', \" - \").concat(message));\n    }\n  }\n\n  _removeIdle() {\n    const toRemove = [];\n    const now = Date.now();\n    let i;\n    let available = this._availableObjects.length;\n    const maxRemovable = this.size - this.minSize;\n    let timeout;\n    this._removeIdleScheduled = false;\n\n    for (i = 0; i < available && maxRemovable > toRemove.length; i++) {\n      timeout = this._availableObjects[i].timeout;\n\n      if (now >= timeout) {\n        this._log('removeIdle() destroying obj - now:' + now + ' timeout:' + timeout, 'verbose');\n\n        toRemove.push(this._availableObjects[i].resource);\n      }\n    }\n\n    toRemove.forEach(this.destroy, this);\n    available = this._availableObjects.length;\n\n    if (available > 0) {\n      this._log('this._availableObjects.length=' + available, 'verbose');\n\n      this._scheduleRemoveIdle();\n    } else {\n      this._log('removeIdle() all objects removed', 'verbose');\n    }\n  }\n\n  _scheduleRemoveIdle() {\n    if (!this._removeIdleScheduled) {\n      this._removeIdleScheduled = true;\n      this._removeIdleTimer = setTimeout(() => {\n        this._removeIdle();\n      }, this.reapIntervalMillis);\n    }\n  }\n\n  _dispense() {\n    let wrappedResource = null;\n    const waitingCount = this._pendingAcquires.length;\n\n    this._log(\"dispense() clients=\".concat(waitingCount, \" available=\").concat(this._availableObjects.length), 'info');\n\n    if (waitingCount < 1) {\n      return;\n    }\n\n    while (this._availableObjects.length > 0) {\n      this._log('dispense() - reusing obj', 'verbose');\n\n      wrappedResource = this._availableObjects[this._availableObjects.length - 1];\n\n      if (!this._factory.validate(wrappedResource.resource)) {\n        this.destroy(wrappedResource.resource);\n        continue;\n      }\n\n      this._availableObjects.pop();\n\n      this._addResourceToInUseObjects(wrappedResource.resource, wrappedResource.useCount);\n\n      const deferred = this._pendingAcquires.shift();\n\n      return deferred.resolve(wrappedResource.resource);\n    }\n\n    if (this.size < this.maxSize) {\n      this._createResource();\n    }\n  }\n\n  _createResource() {\n    this._count += 1;\n\n    this._log(\"createResource() - creating obj - count=\".concat(this.size, \" min=\").concat(this.minSize, \" max=\").concat(this.maxSize), 'verbose');\n\n    this._factory.create().then(resource => {\n      const deferred = this._pendingAcquires.shift();\n\n      if (deferred) {\n        this._addResourceToInUseObjects(resource, 0);\n\n        deferred.resolve(resource);\n      } else {\n        this._addResourceToAvailableObjects(resource, 0);\n      }\n    }).catch(error => {\n      const deferred = this._pendingAcquires.shift();\n\n      this._count -= 1;\n      if (this._count < 0) this._count = 0;\n\n      if (deferred) {\n        deferred.reject(error);\n      }\n\n      process.nextTick(() => {\n        this._dispense();\n      });\n    });\n  }\n\n  _addResourceToAvailableObjects(resource, useCount) {\n    const wrappedResource = {\n      resource: resource,\n      useCount: useCount,\n      timeout: Date.now() + this.idleTimeoutMillis\n    };\n\n    this._availableObjects.push(wrappedResource);\n\n    this._dispense();\n\n    this._scheduleRemoveIdle();\n  }\n\n  _addResourceToInUseObjects(resource, useCount) {\n    const wrappedResource = {\n      resource: resource,\n      useCount: useCount\n    };\n\n    this._inUseObjects.push(wrappedResource);\n  }\n\n  _ensureMinimum() {\n    let i, diff;\n\n    if (!this._draining && this.size < this.minSize) {\n      diff = this.minSize - this.size;\n\n      for (i = 0; i < diff; i++) {\n        this._createResource();\n      }\n    }\n  }\n\n  acquire() {\n    if (this._draining) {\n      return Promise.reject(new Error('pool is draining and cannot accept work'));\n    }\n\n    const deferred = new Deferred_1.Deferred();\n    deferred.registerTimeout(this.acquireTimeoutMillis, () => {\n      this._pendingAcquires = this._pendingAcquires.filter(pending => pending !== deferred);\n    });\n\n    this._pendingAcquires.push(deferred);\n\n    this._dispense();\n\n    return deferred.promise();\n  }\n\n  release(resource) {\n    if (this._availableObjects.some(resourceWithTimeout => resourceWithTimeout.resource === resource)) {\n      this._log('release called twice for the same resource: ' + new Error().stack, 'error');\n\n      return;\n    }\n\n    const index = this._inUseObjects.findIndex(wrappedResource => wrappedResource.resource === resource);\n\n    if (index < 0) {\n      this._log('attempt to release an invalid resource: ' + new Error().stack, 'error');\n\n      return;\n    }\n\n    const wrappedResource = this._inUseObjects[index];\n    wrappedResource.useCount += 1;\n\n    if (wrappedResource.useCount >= this.maxUsesPerResource) {\n      this._log('release() destroying obj - useCount:' + wrappedResource.useCount + ' maxUsesPerResource:' + this.maxUsesPerResource, 'verbose');\n\n      this.destroy(wrappedResource.resource);\n\n      this._dispense();\n    } else {\n      this._inUseObjects.splice(index, 1);\n\n      this._addResourceToAvailableObjects(wrappedResource.resource, wrappedResource.useCount);\n    }\n  }\n\n  destroy(resource) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const available = this._availableObjects.length;\n      const using = this._inUseObjects.length;\n      this._availableObjects = this._availableObjects.filter(object => object.resource !== resource);\n      this._inUseObjects = this._inUseObjects.filter(object => object.resource !== resource);\n\n      if (available === this._availableObjects.length && using === this._inUseObjects.length) {\n        this._ensureMinimum();\n\n        return;\n      }\n\n      this._count -= 1;\n      if (this._count < 0) this._count = 0;\n\n      try {\n        yield this._factory.destroy(resource);\n      } finally {\n        this._ensureMinimum();\n      }\n    });\n  }\n\n  drain() {\n    this._log('draining', 'info');\n\n    this._draining = true;\n\n    const check = callback => {\n      if (this._pendingAcquires.length > 0) {\n        this._dispense();\n\n        setTimeout(() => {\n          check(callback);\n        }, 100);\n        return;\n      }\n\n      if (this._availableObjects.length !== this._count) {\n        setTimeout(() => {\n          check(callback);\n        }, 100);\n        return;\n      }\n\n      callback();\n    };\n\n    return new Promise(resolve => check(resolve));\n  }\n\n  destroyAllNow() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._log('force destroying all objects', 'info');\n\n      this._removeIdleScheduled = false;\n      clearTimeout(this._removeIdleTimer);\n\n      const resources = this._availableObjects.map(resource => resource.resource);\n\n      const errors = [];\n\n      for (const resource of resources) {\n        try {\n          yield this.destroy(resource);\n        } catch (ex) {\n          this._log('Error destroying resource: ' + ex.stack, 'error');\n\n          errors.push(ex);\n        }\n      }\n\n      if (errors.length > 0) {\n        throw new AggregateError_1.AggregateError(errors);\n      }\n    });\n  }\n\n}\n\nexports.Pool = Pool;","map":null,"metadata":{},"sourceType":"script"}