{"ast":null,"code":"'use strict';\n\nconst process = require('process');\n\nconst Readable = require('stream').Readable;\n\nconst Command = require('./command.js');\n\nconst Packets = require('../packets/index.js');\n\nconst getTextParser = require('../parsers/text_parser.js');\n\nconst ServerStatus = require('../constants/server_status.js');\n\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nconst EmptyPacket = new Packets.Packet(0, Buffer.allocUnsafe(4), 0, 4); // http://dev.mysql.com/doc/internals/en/com-query.html\n\nclass Query extends Command {\n  constructor(options, callback) {\n    super();\n    this.sql = options.sql;\n    this.values = options.values;\n    this._queryOptions = options;\n    this.namedPlaceholders = options.namedPlaceholders || false;\n    this.onResult = callback;\n    this._fieldCount = 0;\n    this._rowParser = null;\n    this._fields = [];\n    this._rows = [];\n    this._receivedFieldsCount = 0;\n    this._resultIndex = 0;\n    this._localStream = null;\n\n    this._unpipeStream = function () {};\n\n    this._streamFactory = options.infileStreamFactory;\n    this._connection = null;\n  }\n\n  then() {\n    const err = \"You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://www.npmjs.com/package/mysql2#using-promise-wrapper, or the mysql2 documentation at https://github.com/sidorares/node-mysql2/tree/master/documentation/Promise-Wrapper.md\"; // eslint-disable-next-line\n\n    console.log(err);\n    throw new Error(err);\n  }\n\n  start(packet, connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('        Sending query command: %s', this.sql);\n    }\n\n    this._connection = connection;\n    this.options = Object.assign({}, connection.config, this._queryOptions);\n    const cmdPacket = new Packets.Query(this.sql, connection.config.charsetNumber);\n    connection.writePacket(cmdPacket.toPacket(1));\n    return Query.prototype.resultsetHeader;\n  }\n\n  done() {\n    this._unpipeStream();\n\n    if (this.onResult) {\n      let rows, fields;\n\n      if (this._resultIndex === 0) {\n        rows = this._rows[0];\n        fields = this._fields[0];\n      } else {\n        rows = this._rows;\n        fields = this._fields;\n      }\n\n      if (fields) {\n        process.nextTick(() => {\n          this.onResult(null, rows, fields);\n        });\n      } else {\n        process.nextTick(() => {\n          this.onResult(null, rows);\n        });\n      }\n    }\n\n    return null;\n  }\n\n  doneInsert(rs) {\n    if (this._localStreamError) {\n      if (this.onResult) {\n        this.onResult(this._localStreamError, rs);\n      } else {\n        this.emit('error', this._localStreamError);\n      }\n\n      return null;\n    }\n\n    this._rows.push(rs);\n\n    this._fields.push(void 0);\n\n    this.emit('fields', void 0);\n    this.emit('result', rs);\n\n    if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {\n      this._resultIndex++;\n      return this.resultsetHeader;\n    }\n\n    return this.done();\n  }\n\n  resultsetHeader(packet, connection) {\n    const rs = new Packets.ResultSetHeader(packet, connection);\n    this._fieldCount = rs.fieldCount;\n\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log(\"        Resultset header received, expecting \".concat(rs.fieldCount, \" column definition packets\"));\n    }\n\n    if (this._fieldCount === 0) {\n      return this.doneInsert(rs);\n    }\n\n    if (this._fieldCount === null) {\n      return this._streamLocalInfile(connection, rs.infileName);\n    }\n\n    this._receivedFieldsCount = 0;\n\n    this._rows.push([]);\n\n    this._fields.push([]);\n\n    return this.readField;\n  }\n\n  _streamLocalInfile(connection, path) {\n    if (this._streamFactory) {\n      this._localStream = this._streamFactory(path);\n    } else {\n      this._localStreamError = new Error(\"As a result of LOCAL INFILE command server wants to read \".concat(path, \" file, but as of v2.0 you must provide streamFactory option returning ReadStream.\"));\n      connection.writePacket(EmptyPacket);\n      return this.infileOk;\n    }\n\n    const onConnectionError = () => {\n      this._unpipeStream();\n    };\n\n    const onDrain = () => {\n      this._localStream.resume();\n    };\n\n    const onPause = () => {\n      this._localStream.pause();\n    };\n\n    const onData = function (data) {\n      const dataWithHeader = Buffer.allocUnsafe(data.length + 4);\n      data.copy(dataWithHeader, 4);\n      connection.writePacket(new Packets.Packet(0, dataWithHeader, 0, dataWithHeader.length));\n    };\n\n    const onEnd = () => {\n      connection.removeListener('error', onConnectionError);\n      connection.writePacket(EmptyPacket);\n    };\n\n    const onError = err => {\n      this._localStreamError = err;\n      connection.removeListener('error', onConnectionError);\n      connection.writePacket(EmptyPacket);\n    };\n\n    this._unpipeStream = () => {\n      connection.stream.removeListener('pause', onPause);\n      connection.stream.removeListener('drain', onDrain);\n\n      this._localStream.removeListener('data', onData);\n\n      this._localStream.removeListener('end', onEnd);\n\n      this._localStream.removeListener('error', onError);\n    };\n\n    connection.stream.on('pause', onPause);\n    connection.stream.on('drain', onDrain);\n\n    this._localStream.on('data', onData);\n\n    this._localStream.on('end', onEnd);\n\n    this._localStream.on('error', onError);\n\n    connection.once('error', onConnectionError);\n    return this.infileOk;\n  }\n\n  readField(packet, connection) {\n    this._receivedFieldsCount++; // Often there is much more data in the column definition than in the row itself\n    // If you set manually _fields[0] to array of ColumnDefinition's (from previous call)\n    // you can 'cache' result of parsing. Field packets still received, but ignored in that case\n    // this is the reason _receivedFieldsCount exist (otherwise we could just use current length of fields array)\n\n    if (this._fields[this._resultIndex].length !== this._fieldCount) {\n      const field = new Packets.ColumnDefinition(packet, connection.clientEncoding);\n\n      this._fields[this._resultIndex].push(field);\n\n      if (connection.config.debug) {\n        /* eslint-disable no-console */\n        console.log('        Column definition:');\n        console.log(\"          name: \".concat(field.name));\n        console.log(\"          type: \".concat(field.columnType));\n        console.log(\"         flags: \".concat(field.flags));\n        /* eslint-enable no-console */\n      }\n    } // last field received\n\n\n    if (this._receivedFieldsCount === this._fieldCount) {\n      const fields = this._fields[this._resultIndex];\n      this.emit('fields', fields);\n      this._rowParser = getTextParser(fields, this.options, connection.config);\n      return Query.prototype.fieldsEOF;\n    }\n\n    return Query.prototype.readField;\n  }\n\n  fieldsEOF(packet, connection) {\n    // check EOF\n    if (!packet.isEOF()) {\n      return connection.protocolError('Expected EOF packet');\n    }\n\n    return this.row;\n  }\n\n  row(packet) {\n    if (packet.isEOF()) {\n      const status = packet.eofStatusFlags();\n      const moreResults = status & ServerStatus.SERVER_MORE_RESULTS_EXISTS;\n\n      if (moreResults) {\n        this._resultIndex++;\n        return Query.prototype.resultsetHeader;\n      }\n\n      return this.done();\n    }\n\n    let row;\n\n    try {\n      row = new this._rowParser(packet, this._fields[this._resultIndex], this.options, CharsetToEncoding);\n    } catch (err) {\n      this._localStreamError = err;\n      return this.doneInsert(null);\n    }\n\n    if (this.onResult) {\n      this._rows[this._resultIndex].push(row);\n    } else {\n      this.emit('result', row);\n    }\n\n    return Query.prototype.row;\n  }\n\n  infileOk(packet, connection) {\n    const rs = new Packets.ResultSetHeader(packet, connection);\n    return this.doneInsert(rs);\n  }\n\n  stream(options) {\n    options = options || {};\n    options.objectMode = true;\n    const stream = new Readable(options);\n\n    stream._read = () => {\n      this._connection && this._connection.resume();\n    };\n\n    this.on('result', row => {\n      if (!stream.push(row)) {\n        this._connection.pause();\n      }\n\n      stream.emit('result', row); // replicate old emitter\n    });\n    this.on('error', err => {\n      stream.emit('error', err); // Pass on any errors\n    });\n    this.on('end', () => {\n      stream.push(null); // pushing null, indicating EOF\n\n      stream.emit('close'); // notify readers that query has completed\n    });\n    this.on('fields', fields => {\n      stream.emit('fields', fields); // replicate old emitter\n    });\n    return stream;\n  }\n\n}\n\nQuery.prototype.catch = Query.prototype.then;\nmodule.exports = Query;","map":null,"metadata":{},"sourceType":"script"}